---
phase: 01-foundation-core-rag
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/core/__init__.py
  - backend/app/core/auth.py
  - backend/app/core/security.py
  - backend/app/core/exceptions.py
  - backend/app/models/user.py
  - backend/app/models/schemas.py
  - backend/app/api/auth.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "User can register with email and password"
    - "User can login and receive JWT access token"
    - "User can logout (token invalidation acknowledged)"
    - "Protected endpoints reject requests without valid JWT"
  artifacts:
    - path: "backend/app/core/auth.py"
      provides: "JWT creation, validation, password hashing"
      exports: ["hash_password", "verify_password", "create_access_token", "decode_access_token"]
    - path: "backend/app/core/security.py"
      provides: "FastAPI security dependency"
      exports: ["get_current_user", "oauth2_scheme"]
    - path: "backend/app/api/auth.py"
      provides: "Auth API routes"
      contains: "router = APIRouter"
    - path: "backend/app/models/user.py"
      provides: "User operations in Neo4j"
      exports: ["create_user", "get_user_by_email"]
  key_links:
    - from: "backend/app/api/auth.py"
      to: "backend/app/core/auth.py"
      via: "password and token operations"
      pattern: "hash_password|create_access_token"
    - from: "backend/app/core/security.py"
      to: "backend/app/db/neo4j_client.py"
      via: "user lookup"
      pattern: "get_user_by_email"
    - from: "backend/app/main.py"
      to: "backend/app/api/auth.py"
      via: "router include"
      pattern: "include_router.*auth"
---

<objective>
Implement complete JWT authentication system with user registration and login.

Purpose: Enable secure user authentication required for document uploads and queries. All subsequent endpoints depend on this for user isolation.
Output: Working /auth/register, /auth/login, /auth/logout endpoints with JWT tokens. get_current_user dependency for protecting routes.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-rag/01-RESEARCH.md
@.planning/phases/01-foundation-core-rag/01-01-SUMMARY.md

Reference research patterns:
- Pattern 5: JWT Authentication with FastAPI Security
- Pitfall 4: JWT Security Vulnerabilities (CRITICAL)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JWT auth core with password hashing</name>
  <files>
    backend/app/core/auth.py
    backend/app/core/exceptions.py
    backend/app/models/user.py
  </files>
  <action>
    1. Create `backend/app/core/exceptions.py`:
       - Custom exception classes for auth errors
       - CredentialsException(HTTPException): 401, "Could not validate credentials"
       - UserExistsException(HTTPException): 400, "Email already registered"

    2. Create `backend/app/core/auth.py` following research Pattern 5:
       - Import jwt (NOT jose, NOT python-jose - use pyjwt)
       - Import PasswordHash, Argon2Hasher from pwdlib, pwdlib.hashers.argon2
       - Import datetime, timedelta, timezone from datetime
       - Import settings from app.config

       Password hashing:
       - password_hash = PasswordHash((Argon2Hasher(),))
       - verify_password(plain_password: str, hashed_password: str) -> bool
       - hash_password(password: str) -> str

       JWT tokens:
       - create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str
         - Use datetime.now(timezone.utc) for timezone-aware timestamps
         - Default expiry from settings.ACCESS_TOKEN_EXPIRE_MINUTES
         - Encode with settings.SECRET_KEY and settings.ALGORITHM
       - decode_access_token(token: str) -> Optional[dict]
         - Handle jwt.ExpiredSignatureError -> None
         - Handle jwt.InvalidTokenError -> None
         - NEVER accept algorithm="none"

    3. Create `backend/app/models/user.py`:
       - Import neo4j_driver from app.db.neo4j_client
       - Import settings from app.config
       - import uuid

       Functions:
       - create_user(email: str, hashed_password: str, user_id: str) -> dict
         - CREATE (u:User {id, email, hashed_password, created_at: datetime()})
         - RETURN u
       - get_user_by_email(email: str) -> Optional[dict]
         - MATCH (u:User {email: $email}) RETURN u
         - Return dict(record["u"]) if found, None otherwise
       - get_user_by_id(user_id: str) -> Optional[dict]
         - MATCH (u:User {id: $user_id}) RETURN u

    CRITICAL: Use Argon2 (GPU-resistant). Never log passwords or full tokens.
  </action>
  <verify>
    cd backend && python -c "from app.core.auth import hash_password, verify_password; h = hash_password('test'); print(verify_password('test', h))"
    cd backend && python -c "from app.core.auth import create_access_token, decode_access_token; t = create_access_token({'sub': 'test@example.com'}); print(decode_access_token(t))"
  </verify>
  <done>
    Password hashing with Argon2 works correctly. JWT creation and decoding work with proper expiration handling. User model functions are ready for Neo4j operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth API routes and security dependency</name>
  <files>
    backend/app/core/security.py
    backend/app/models/schemas.py
    backend/app/api/auth.py
    backend/app/main.py
  </files>
  <action>
    1. Create `backend/app/models/schemas.py`:
       - Pydantic models for request/response validation
       - UserRegister(BaseModel): email (EmailStr), password (str)
       - UserLogin uses OAuth2PasswordRequestForm (handled in route)
       - Token(BaseModel): access_token (str), token_type (str)
       - UserResponse(BaseModel): id (str), email (str)
       - MessageResponse(BaseModel): message (str)

    2. Create `backend/app/core/security.py` following research Pattern 5:
       - Import OAuth2PasswordBearer from fastapi.security
       - Import get_current_user dependency function

       oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

       async def get_current_user(token: str = Depends(oauth2_scheme)) -> dict:
         - Decode token using decode_access_token
         - Extract email from "sub" claim
         - Look up user via get_user_by_email
         - Raise CredentialsException if any step fails
         - Return user dict

    3. Create `backend/app/api/auth.py` following research Pattern 5:
       - router = APIRouter()

       POST /register (API-07, AUTH-01):
         - Accept UserRegister body
         - Check if user exists (get_user_by_email)
         - Raise UserExistsException if exists
         - Generate user_id with uuid4
         - Hash password
         - Create user in Neo4j
         - Generate access token
         - Return Token with 201 status

       POST /login (API-08, AUTH-02):
         - Use OAuth2PasswordRequestForm for compatibility with FastAPI docs
         - Look up user by form_data.username (email)
         - Verify password
         - Return 401 if invalid
         - Generate access token
         - Return Token

       POST /logout (API-10, AUTH-07):
         - JWT is stateless - actual invalidation is client-side
         - This endpoint exists for API completeness
         - Return MessageResponse with "Successfully logged out"
         - NOTE: Server-side token invalidation requires token blocklist (Phase 2+)

    4. Update `backend/app/main.py`:
       - Import auth router: from app.api.auth import router as auth_router
       - Include router: app.include_router(auth_router, prefix=f"{settings.API_V1_PREFIX}/auth", tags=["auth"])
  </action>
  <verify>
    cd backend && python -c "from app.api.auth import router; print(f'Auth routes: {[r.path for r in router.routes]}')"
    cd backend && python -c "from app.core.security import get_current_user, oauth2_scheme; print('Security dependency imported')"
    cd backend && python -c "from app.main import app; print([r.path for r in app.routes if 'auth' in r.path])"
  </verify>
  <done>
    Auth routes exist at /api/v1/auth/register, /api/v1/auth/login, /api/v1/auth/logout. Security dependency get_current_user is ready for protecting routes. FastAPI docs at /docs shows auth endpoints.
  </done>
</task>

</tasks>

<verification>
1. Password hashing: hash then verify returns True
2. JWT: create token, decode returns original data
3. Register endpoint: POST /api/v1/auth/register creates user and returns token
4. Login endpoint: POST /api/v1/auth/login with valid credentials returns token
5. Login endpoint: Returns 401 for invalid credentials
6. Logout endpoint: POST /api/v1/auth/logout returns success message
7. FastAPI OpenAPI docs show auth endpoints with correct request/response models
</verification>

<success_criteria>
- `curl -X POST /api/v1/auth/register -d '{"email":"test@example.com","password":"test123"}' -H "Content-Type: application/json"` returns 201 with access_token
- `curl -X POST /api/v1/auth/login -d "username=test@example.com&password=test123"` returns 200 with access_token
- Duplicate registration returns 400 "Email already registered"
- Invalid login returns 401 "Incorrect email or password"
- Token can be decoded and contains "sub" claim with email
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-rag/01-02-SUMMARY.md`
</output>
