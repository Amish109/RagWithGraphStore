---
phase: 01-foundation-core-rag
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/__init__.py
  - backend/app/main.py
  - backend/app/config.py
  - backend/app/db/__init__.py
  - backend/app/db/neo4j_client.py
  - backend/app/db/qdrant_client.py
  - backend/pyproject.toml
  - backend/requirements.txt
  - backend/.env.example
autonomous: true

user_setup:
  - service: neo4j
    why: "Graph database for knowledge storage"
    env_vars:
      - name: NEO4J_URI
        source: "Neo4j Aura or local Docker instance"
      - name: NEO4J_PASSWORD
        source: "Set during Neo4j installation"
  - service: qdrant
    why: "Vector database for embeddings"
    env_vars:
      - name: QDRANT_HOST
        source: "Qdrant Cloud or local Docker (localhost:6333)"
  - service: openai
    why: "LLM and embeddings provider"
    env_vars:
      - name: OPENAI_API_KEY
        source: "OpenAI Dashboard -> API keys"

must_haves:
  truths:
    - "FastAPI app starts and responds to health check"
    - "Neo4j connection is verified at startup"
    - "Qdrant collection exists with correct dimensions"
    - "All configuration loads from environment variables"
  artifacts:
    - path: "backend/app/config.py"
      provides: "Centralized Pydantic BaseSettings configuration"
      contains: "class Settings"
    - path: "backend/app/main.py"
      provides: "FastAPI app with lifespan events"
      contains: "asynccontextmanager"
    - path: "backend/app/db/neo4j_client.py"
      provides: "Neo4j driver and schema initialization"
      exports: ["neo4j_driver", "init_neo4j_schema"]
    - path: "backend/app/db/qdrant_client.py"
      provides: "Qdrant client and collection setup"
      exports: ["qdrant_client", "init_qdrant_collection"]
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/config.py"
      via: "settings import"
      pattern: "from app.config import settings"
    - from: "backend/app/main.py"
      to: "backend/app/db/neo4j_client.py"
      via: "lifespan startup"
      pattern: "neo4j_driver.verify_connectivity"
    - from: "backend/app/main.py"
      to: "backend/app/db/qdrant_client.py"
      via: "lifespan startup"
      pattern: "init_qdrant_collection"
---

<objective>
Create the foundational project structure with Pydantic configuration and database connections.

Purpose: Establish the infrastructure layer that all subsequent plans depend on. Configuration management and database connectivity must be correct from day one.
Output: Working FastAPI application with health check, Neo4j connection with schema, Qdrant collection with correct dimensions.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-rag/01-RESEARCH.md

Reference research patterns:
- Pattern 1: Configuration Management with Pydantic BaseSettings
- Pattern 2: FastAPI App Setup with Lifespan Events
- Pattern 3: Neo4j Connection and Schema Setup
- Pattern 4: Qdrant Connection and Collection Setup
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project structure and dependencies</name>
  <files>
    backend/pyproject.toml
    backend/requirements.txt
    backend/app/__init__.py
    backend/app/api/__init__.py
    backend/app/core/__init__.py
    backend/app/db/__init__.py
    backend/app/services/__init__.py
    backend/app/models/__init__.py
    backend/app/utils/__init__.py
    backend/.env.example
  </files>
  <action>
    Create the backend project structure following research Pattern architecture.

    1. Create `backend/pyproject.toml` with:
       - Project name: "rag-with-graph-store"
       - Python 3.10+ requirement
       - Dependencies from research standard stack:
         - fastapi>=0.126.0
         - pydantic>=2.7.0
         - pydantic-settings>=2.0.0
         - uvicorn[standard]
         - mem0ai
         - neo4j>=6.1.0
         - qdrant-client>=1.16.2
         - langchain>=1.0
         - langchain-openai>=1.1.7
         - pymupdf4llm
         - python-docx
         - pyjwt
         - pwdlib[argon2]
         - python-dotenv
         - openai
       - Dev dependencies: pytest, pytest-asyncio, httpx

    2. Create `backend/requirements.txt` with pinned versions matching pyproject.toml

    3. Create all `__init__.py` files for package structure:
       - backend/app/
       - backend/app/api/
       - backend/app/core/
       - backend/app/db/
       - backend/app/services/
       - backend/app/models/
       - backend/app/utils/

    4. Create `backend/.env.example` with all required environment variables:
       - SECRET_KEY (32+ byte hex, required for JWT)
       - NEO4J_URI, NEO4J_USERNAME, NEO4J_PASSWORD, NEO4J_DATABASE
       - QDRANT_HOST, QDRANT_PORT, QDRANT_API_KEY (optional for cloud)
       - OPENAI_API_KEY, OPENAI_MODEL, OPENAI_EMBEDDING_MODEL, OPENAI_EMBEDDING_DIMENSIONS
       - CHUNK_SIZE, CHUNK_OVERLAP, MAX_UPLOAD_SIZE_MB
       - LOG_LEVEL
  </action>
  <verify>
    ls -la backend/app/
    ls -la backend/app/api/ backend/app/core/ backend/app/db/
    cat backend/pyproject.toml
  </verify>
  <done>
    All package directories exist with __init__.py files. pyproject.toml has all dependencies from research. .env.example documents all required environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Pydantic configuration and FastAPI app</name>
  <files>
    backend/app/config.py
    backend/app/main.py
  </files>
  <action>
    1. Create `backend/app/config.py` following research Pattern 1 exactly:
       - Import from pydantic_settings (not pydantic)
       - BaseSettings with SettingsConfigDict for env file loading
       - All settings from research: PROJECT_NAME, VERSION, API_V1_PREFIX
       - Security: SECRET_KEY (required), ALGORITHM="HS256", ACCESS_TOKEN_EXPIRE_MINUTES=30
       - Neo4j: NEO4J_URI, NEO4J_USERNAME, NEO4J_PASSWORD (required), NEO4J_DATABASE
       - Qdrant: QDRANT_HOST, QDRANT_PORT, QDRANT_API_KEY (optional), QDRANT_COLLECTION
       - OpenAI: OPENAI_API_KEY (required), OPENAI_MODEL, OPENAI_EMBEDDING_MODEL, OPENAI_EMBEDDING_DIMENSIONS=1536
       - Document processing: CHUNK_SIZE=1000, CHUNK_OVERLAP=200, MAX_UPLOAD_SIZE_MB=50
       - Logging: LOG_LEVEL="INFO"
       - Global `settings = Settings()` instance

    2. Create `backend/app/main.py` following research Pattern 2:
       - Import asynccontextmanager from contextlib
       - Create lifespan context manager with startup/shutdown logic
       - Startup: verify Neo4j connectivity, verify Qdrant, validate embedding dimensions (placeholder for now)
       - Shutdown: close Neo4j and Qdrant connections
       - FastAPI app with title from settings, version, lifespan
       - CORS middleware for localhost:3000
       - Health check endpoint at /health returning status and version
       - Router includes will be added in subsequent plans

    CRITICAL: Do NOT import database clients yet (they don't exist). Use placeholder comments for startup checks.
  </action>
  <verify>
    cd backend && python -c "from app.config import settings; print(f'Project: {settings.PROJECT_NAME}')"
    cd backend && python -c "from app.main import app; print(f'App title: {app.title}')"
  </verify>
  <done>
    config.py loads settings from environment. main.py creates FastAPI app with lifespan. Python imports work without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Initialize database clients with schema</name>
  <files>
    backend/app/db/neo4j_client.py
    backend/app/db/qdrant_client.py
    backend/app/main.py
  </files>
  <action>
    1. Create `backend/app/db/neo4j_client.py` following research Pattern 3:
       - Import GraphDatabase from neo4j
       - Create neo4j_driver singleton using settings
       - Connection pool settings: max_connection_lifetime=3600, max_connection_pool_size=50
       - close_neo4j() function for cleanup
       - init_neo4j_schema() function that creates:
         - CONSTRAINT user_id_unique FOR (u:User) REQUIRE u.id IS UNIQUE
         - CONSTRAINT document_id_unique FOR (d:Document) REQUIRE d.id IS UNIQUE
         - CONSTRAINT chunk_id_unique FOR (c:Chunk) REQUIRE c.id IS UNIQUE
         - INDEX user_email FOR (u:User) ON (u.email)
         - INDEX document_user_id FOR (d:Document) ON (d.user_id)
         - INDEX chunk_document_id FOR (c:Chunk) ON (c.document_id)
       - Use IF NOT EXISTS for all constraints/indexes

    2. Create `backend/app/db/qdrant_client.py` following research Pattern 4:
       - Import QdrantClient, VectorParams, Distance from qdrant_client
       - Conditional client init: use API key for cloud, host/port for local
       - close_qdrant() function for cleanup
       - init_qdrant_collection() function that:
         - Checks if collection exists
         - Creates collection with size=OPENAI_EMBEDDING_DIMENSIONS, distance=COSINE
         - Creates payload indexes on user_id and document_id

    3. Update `backend/app/main.py`:
       - Import neo4j_driver, close_neo4j, init_neo4j_schema from db.neo4j_client
       - Import qdrant_client, close_qdrant, init_qdrant_collection from db.qdrant_client
       - In lifespan startup:
         - neo4j_driver.verify_connectivity()
         - init_neo4j_schema()
         - qdrant_client.get_collections() (verify connection)
         - init_qdrant_collection()
       - In lifespan shutdown: close_neo4j(), close_qdrant()
       - Add placeholder comment for embedding dimension validation (implemented in Plan 03)
  </action>
  <verify>
    cd backend && python -c "from app.db.neo4j_client import neo4j_driver, init_neo4j_schema; print('Neo4j client imported')"
    cd backend && python -c "from app.db.qdrant_client import qdrant_client, init_qdrant_collection; print('Qdrant client imported')"
    cd backend && python -c "from app.main import app; print('App with db imports works')"
  </verify>
  <done>
    Neo4j client connects with schema initialization. Qdrant client creates collection with correct dimensions. main.py lifespan verifies both connections at startup.
  </done>
</task>

</tasks>

<verification>
1. Project structure exists with all required directories
2. pyproject.toml contains all dependencies from research
3. .env.example documents all required environment variables
4. config.py validates required fields (SECRET_KEY, NEO4J_PASSWORD, OPENAI_API_KEY)
5. Neo4j client can verify connectivity (requires running Neo4j instance)
6. Qdrant client can create collection (requires running Qdrant instance)
7. FastAPI app starts: `cd backend && uvicorn app.main:app --reload` responds to GET /health
</verification>

<success_criteria>
- `python -c "from app.config import settings"` works without error
- `python -c "from app.main import app"` works without error
- GET /health returns {"status": "healthy", "version": "..."}
- Neo4j schema has User, Document, Chunk constraints and indexes
- Qdrant collection exists with 1536-dimension vectors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-rag/01-01-SUMMARY.md`
</output>
