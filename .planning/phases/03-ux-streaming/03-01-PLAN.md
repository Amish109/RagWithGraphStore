---
phase: 03-ux-streaming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/core/exceptions.py
  - backend/app/core/error_handlers.py
  - backend/app/models/schemas.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "Errors display helpful messages to users rather than crashing or showing stack traces"
    - "API returns consistent error response format across all endpoints"
    - "Internal errors are logged but not exposed to users"
  artifacts:
    - path: "backend/app/core/error_handlers.py"
      provides: "Global exception handlers"
      exports: ["register_exception_handlers"]
    - path: "backend/app/core/exceptions.py"
      provides: "Domain-specific exceptions"
      contains: "class DocumentNotFoundError"
    - path: "backend/app/models/schemas.py"
      provides: "ErrorResponse schema"
      contains: "class ErrorResponse"
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/core/error_handlers.py"
      via: "register_exception_handlers(app) call"
      pattern: "register_exception_handlers"
    - from: "backend/app/core/error_handlers.py"
      to: "backend/app/models/schemas.py"
      via: "ErrorResponse import"
      pattern: "from app.models.schemas import ErrorResponse"
---

<objective>
Implement global exception handling for user-friendly error responses

Purpose: Ensure all API errors return consistent, helpful messages without exposing internal details (stack traces, database errors). This is critical UX and a prerequisite for streaming endpoints.

Output: Global exception handlers registered in main.py, domain exceptions in exceptions.py, ErrorResponse schema in schemas.py
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-ux-streaming/03-RESEARCH.md

# Existing files to modify
@backend/app/core/exceptions.py
@backend/app/models/schemas.py
@backend/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ErrorResponse schema and domain exceptions</name>
  <files>
    backend/app/models/schemas.py
    backend/app/core/exceptions.py
  </files>
  <action>
1. Add ErrorResponse schema to schemas.py:
```python
class ErrorResponse(BaseModel):
    """Schema for standardized error responses."""
    error: str  # Error type identifier (e.g., "validation_error", "not_found")
    message: str  # User-friendly message
    detail: Optional[str] = None  # Optional additional context
```

2. Expand exceptions.py with domain-specific exceptions:
```python
class DocumentNotFoundError(HTTPException):
    """Raised when document not found or not owned by user."""
    def __init__(self, document_id: str):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Document not found: {document_id}"
        )

class DocumentProcessingError(HTTPException):
    """Raised when document processing fails."""
    def __init__(self, message: str = "Document processing failed"):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=message
        )

class QueryGenerationError(HTTPException):
    """Raised when LLM query generation fails."""
    def __init__(self, message: str = "Failed to generate response"):
        super().__init__(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=message
        )
```
  </action>
  <verify>
python -c "from app.models.schemas import ErrorResponse; print('ErrorResponse OK')"
python -c "from app.core.exceptions import DocumentNotFoundError, DocumentProcessingError, QueryGenerationError; print('Exceptions OK')"
  </verify>
  <done>ErrorResponse schema exists with error, message, detail fields. Domain exceptions exist for Document and Query errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create global exception handlers</name>
  <files>
    backend/app/core/error_handlers.py
  </files>
  <action>
Create new file backend/app/core/error_handlers.py with global exception handlers:

```python
"""Global exception handlers for consistent error responses.

Registers handlers for:
- RequestValidationError: Pydantic validation failures (422)
- HTTPException: Explicit API errors (various)
- Exception: Catch-all for unhandled errors (500)

CRITICAL: Never expose stack traces or internal details to users.
Log full details internally, return sanitized messages externally.
"""
import logging
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

from app.models.schemas import ErrorResponse

logger = logging.getLogger(__name__)


async def validation_exception_handler(
    request: Request, exc: RequestValidationError
) -> JSONResponse:
    """Handle Pydantic validation errors with user-friendly messages."""
    # Extract first error for user message
    errors = exc.errors()
    if errors:
        first_error = errors[0]
        field = ".".join(str(x) for x in first_error.get("loc", []))
        msg = first_error.get("msg", "Invalid value")
        user_message = f"Invalid {field}: {msg}" if field else msg
    else:
        user_message = "Invalid request data"

    return JSONResponse(
        status_code=422,
        content=ErrorResponse(
            error="validation_error",
            message=user_message,
            detail=str(errors) if errors else None
        ).model_dump()
    )


async def http_exception_handler(
    request: Request, exc: HTTPException
) -> JSONResponse:
    """Handle explicit HTTP exceptions."""
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            error=_status_to_error_type(exc.status_code),
            message=str(exc.detail),
        ).model_dump(),
        headers=getattr(exc, "headers", None)
    )


async def generic_exception_handler(
    request: Request, exc: Exception
) -> JSONResponse:
    """Handle unhandled exceptions - log internally, sanitize externally.

    CRITICAL: Never expose internal details to users.
    """
    # Log full exception for debugging
    logger.exception(f"Unhandled exception on {request.method} {request.url.path}: {exc}")

    # Return sanitized response
    return JSONResponse(
        status_code=500,
        content=ErrorResponse(
            error="internal_error",
            message="An unexpected error occurred. Please try again later."
        ).model_dump()
    )


def _status_to_error_type(status_code: int) -> str:
    """Map HTTP status codes to error type strings."""
    mapping = {
        400: "bad_request",
        401: "unauthorized",
        403: "forbidden",
        404: "not_found",
        409: "conflict",
        422: "validation_error",
        429: "rate_limited",
        500: "internal_error",
        503: "service_unavailable",
    }
    return mapping.get(status_code, "error")


def register_exception_handlers(app: FastAPI) -> None:
    """Register all exception handlers on the FastAPI app."""
    app.add_exception_handler(RequestValidationError, validation_exception_handler)
    app.add_exception_handler(HTTPException, http_exception_handler)
    app.add_exception_handler(Exception, generic_exception_handler)
```
  </action>
  <verify>
python -c "from app.core.error_handlers import register_exception_handlers; print('Handlers OK')"
  </verify>
  <done>error_handlers.py exists with validation_exception_handler, http_exception_handler, generic_exception_handler, and register_exception_handlers function.</done>
</task>

<task type="auto">
  <name>Task 3: Register handlers in main.py and test</name>
  <files>
    backend/app/main.py
  </files>
  <action>
1. Add import at top of main.py:
```python
from app.core.error_handlers import register_exception_handlers
```

2. After `app = FastAPI(...)` and before CORS middleware, add:
```python
# Register global exception handlers
register_exception_handlers(app)
```

3. Test the error handling works by making invalid requests.
  </action>
  <verify>
# Start server and test error handling
cd /Users/apple/Desktop/RAGWithGraphStore/backend
# Test validation error (missing required field)
curl -X POST http://localhost:8000/api/v1/auth/register -H "Content-Type: application/json" -d '{"email": "invalid"}' 2>/dev/null | python -c "import sys,json; d=json.load(sys.stdin); assert 'error' in d and 'message' in d, f'Bad response: {d}'; print('Validation error format OK')"
# Test 404 error
curl -X GET http://localhost:8000/api/v1/nonexistent 2>/dev/null | python -c "import sys,json; d=json.load(sys.stdin); assert 'error' in d or 'detail' in d; print('404 error format OK')"
  </verify>
  <done>Exception handlers registered in main.py. All errors return consistent ErrorResponse format with error type and user-friendly message.</done>
</task>

</tasks>

<verification>
# Verify error handling implementation
cd /Users/apple/Desktop/RAGWithGraphStore/backend

# 1. Check files exist
test -f app/core/error_handlers.py && echo "error_handlers.py exists"

# 2. Verify imports work
python -c "
from app.core.error_handlers import register_exception_handlers
from app.core.exceptions import DocumentNotFoundError, DocumentProcessingError
from app.models.schemas import ErrorResponse
print('All imports successful')
"

# 3. Verify ErrorResponse schema
python -c "
from app.models.schemas import ErrorResponse
r = ErrorResponse(error='test', message='Test message')
assert r.error == 'test'
assert r.message == 'Test message'
print('ErrorResponse schema valid')
"
</verification>

<success_criteria>
1. ErrorResponse schema exists with error, message, detail fields
2. Domain exceptions (DocumentNotFoundError, DocumentProcessingError, QueryGenerationError) exist
3. Global exception handlers registered in main.py via register_exception_handlers()
4. Validation errors return 422 with structured ErrorResponse
5. Unhandled exceptions return 500 with generic message (no stack traces)
6. All errors logged internally with full details
</success_criteria>

<output>
After completion, create `.planning/phases/03-ux-streaming/03-01-SUMMARY.md`
</output>
