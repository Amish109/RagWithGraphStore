---
phase: 07-foundation-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/.env
  - frontend/utils/__init__.py
  - frontend/utils/api_client.py
  - frontend/utils/session.py
  - frontend/pages/__init__.py
autonomous: true

must_haves:
  truths:
    - "API client can make authenticated requests to backend"
    - "Session state is properly initialized on app start"
  artifacts:
    - path: "frontend/utils/api_client.py"
      provides: "httpx AsyncClient wrapper with auth header injection"
      min_lines: 40
    - path: "frontend/utils/session.py"
      provides: "Session state initialization and user info helpers"
      min_lines: 30
    - path: "frontend/.env"
      provides: "API base URL configuration"
      contains: "API_BASE_URL"
  key_links:
    - from: "frontend/utils/api_client.py"
      to: "http://localhost:8000"
      via: "httpx.AsyncClient base_url"
      pattern: "base_url.*localhost:8000"
---

<objective>
Create Streamlit frontend project structure with API client and session state utilities.

Purpose: Establish foundational infrastructure for all frontend authentication and API communication.
Output: frontend/ directory with utils/api_client.py (httpx wrapper), utils/session.py (session state helpers), and .env configuration.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foundation-authentication/07-RESEARCH.md
@backend/app/api/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Streamlit project structure and configuration</name>
  <files>
    frontend/.env
    frontend/utils/__init__.py
    frontend/pages/__init__.py
  </files>
  <action>
Create the frontend directory structure following research recommendations:

1. Create `frontend/.env`:
```
API_BASE_URL=http://localhost:8000
```

2. Create `frontend/utils/__init__.py`:
```python
"""Utility modules for Streamlit frontend."""
from .api_client import get_api_client
from .session import init_session_state, get_user_info

__all__ = ["get_api_client", "init_session_state", "get_user_info"]
```

3. Create `frontend/pages/__init__.py`:
```python
"""Page modules for Streamlit multi-page app."""
```

4. Create `frontend/requirements.txt`:
```
streamlit>=1.40.0
httpx>=0.28.1
pyjwt>=2.0.0
python-dotenv>=1.0.0
```

Note: Do NOT create app.py yet - that's in Plan 04 after auth flows are ready.
  </action>
  <verify>
```bash
ls -la frontend/
ls -la frontend/utils/
ls -la frontend/pages/
cat frontend/.env
cat frontend/requirements.txt
```
All files exist with correct content.
  </verify>
  <done>
- frontend/.env exists with API_BASE_URL=http://localhost:8000
- frontend/utils/__init__.py exists with imports
- frontend/pages/__init__.py exists
- frontend/requirements.txt exists with dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement API client with httpx AsyncClient</name>
  <files>frontend/utils/api_client.py</files>
  <action>
Create httpx AsyncClient wrapper following Pattern 2 from research.

Implementation requirements:
1. Use @st.cache_resource to create singleton AsyncClient (prevents connection leaks)
2. Base URL from environment variable (API_BASE_URL)
3. Include method to add Authorization header with Bearer token from session_state
4. Provide async methods for login, register, logout, refresh
5. Use asyncio.run() wrapper for sync convenience (Streamlit callbacks are sync)

Key patterns to follow:
- Login endpoint uses OAuth2 form data format (username=email, password=password)
- Register endpoint uses JSON body with {email, password}
- Logout endpoint requires Authorization header
- Refresh endpoint uses JSON body with {refresh_token}

Backend endpoint contract (from auth.py):
- POST /api/v1/auth/login - form data, returns {access_token, refresh_token, token_type}
- POST /api/v1/auth/register - JSON, returns {access_token, refresh_token, token_type}
- POST /api/v1/auth/logout - requires Bearer token, returns {message}
- POST /api/v1/auth/refresh - JSON with refresh_token, returns new token pair

Avoid:
- Creating new AsyncClient per request (resource leak)
- Storing client in session_state (can't pickle)
- Using requests library (not async-native)
  </action>
  <verify>
```bash
cd frontend && python -c "from utils.api_client import get_api_client, login, register, logout, refresh_tokens; print('API client imports work')"
```
Import succeeds without errors.
  </verify>
  <done>
- get_api_client() returns cached httpx.AsyncClient
- login(email, password) calls POST /api/v1/auth/login with form data
- register(email, password) calls POST /api/v1/auth/register with JSON
- logout(access_token) calls POST /api/v1/auth/logout with Bearer header
- refresh_tokens(refresh_token) calls POST /api/v1/auth/refresh with JSON
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement session state utilities</name>
  <files>frontend/utils/session.py</files>
  <action>
Create session state initialization and helper functions following Pattern 3 and Pattern 5 from research.

Implementation requirements:
1. init_session_state() - Initialize all auth-related keys with defaults:
   - is_authenticated: bool (False)
   - access_token: Optional[str] (None)
   - refresh_token: Optional[str] (None)
   - user_info: Optional[dict] (None) - decoded JWT claims
   - session_type: str ("anonymous" | "authenticated")

2. get_user_info() - Return dict with:
   - email: str (from JWT sub claim or "Anonymous")
   - user_id: str (from JWT user_id claim or "N/A")
   - role: str (from JWT role claim or "anonymous")
   - session_type: str ("authenticated" | "anonymous")

3. is_token_expired(token: str) -> bool - Check JWT exp claim without verification:
   - Decode without signature verification (options={"verify_signature": False})
   - Compare exp timestamp to current UTC time
   - Return True if expired or invalid

4. get_token_expiry_seconds(token: str) -> int - Return seconds until expiry:
   - Return 0 if expired or invalid

5. clear_auth_state() - Reset all auth keys to defaults:
   - Called on logout or session invalidation

Key patterns:
- Use pyjwt for decode without verification (just reading claims)
- Store decoded user_info in session_state to avoid repeated decoding
- Session type tracks whether user is authenticated or anonymous

Avoid:
- Storing passwords in session_state (even temporarily)
- Verifying JWT signature (backend already verified)
- Putting datetime objects in session_state (not JSON serializable)
  </action>
  <verify>
```bash
cd frontend && python -c "
from utils.session import init_session_state, get_user_info, is_token_expired, get_token_expiry_seconds, clear_auth_state
print('Session utils imports work')
# Test is_token_expired with invalid token
assert is_token_expired('invalid') == True, 'Invalid token should be expired'
print('is_token_expired works')
"
```
All imports work and is_token_expired handles invalid tokens.
  </verify>
  <done>
- init_session_state() initializes all auth keys
- get_user_info() returns user details from session_state
- is_token_expired() checks JWT exp claim
- get_token_expiry_seconds() returns seconds until expiry
- clear_auth_state() resets auth to defaults
  </done>
</task>

</tasks>

<verification>
1. Directory structure exists:
   ```bash
   ls -la frontend/
   ls -la frontend/utils/
   ls -la frontend/pages/
   ```

2. Python imports work:
   ```bash
   cd frontend && python -c "
   from utils.api_client import get_api_client, login, register
   from utils.session import init_session_state, get_user_info
   print('All imports successful')
   "
   ```

3. Environment configuration correct:
   ```bash
   grep API_BASE_URL frontend/.env
   ```
</verification>

<success_criteria>
- frontend/ directory exists with proper structure
- utils/api_client.py exports get_api_client, login, register, logout, refresh_tokens
- utils/session.py exports init_session_state, get_user_info, is_token_expired, clear_auth_state
- .env contains API_BASE_URL=http://localhost:8000
- All Python files import without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation-authentication/07-01-SUMMARY.md`
</output>
