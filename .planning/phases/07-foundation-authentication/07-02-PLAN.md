---
phase: 07-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - frontend/pages/login.py
  - frontend/utils/auth.py
autonomous: true

must_haves:
  truths:
    - "User can enter email and password in login form"
    - "User sees error message when credentials are invalid"
    - "Session state is updated with tokens on successful login"
  artifacts:
    - path: "frontend/pages/login.py"
      provides: "Login page with form and callback handler"
      min_lines: 40
    - path: "frontend/utils/auth.py"
      provides: "Authentication callback handlers"
      min_lines: 30
  key_links:
    - from: "frontend/pages/login.py"
      to: "frontend/utils/auth.py"
      via: "handle_login callback import"
      pattern: "from utils.auth import handle_login"
    - from: "frontend/utils/auth.py"
      to: "frontend/utils/api_client.py"
      via: "login function call"
      pattern: "from utils.api_client import login"
---

<objective>
Implement login page with callback-based authentication flow.

Purpose: Enable users to authenticate with email/password using patterns that prevent infinite rerun loops.
Output: Login page (pages/login.py) and auth utilities (utils/auth.py) with callback-based login flow.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-foundation-authentication/07-RESEARCH.md
@.planning/phases/07-foundation-authentication/07-01-SUMMARY.md
@backend/app/api/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth callback handlers</name>
  <files>frontend/utils/auth.py</files>
  <action>
Create authentication callback handlers following Pattern 3 from research.

Implementation requirements:

1. handle_login() callback:
   - Read email from st.session_state.login_email (set by text_input key)
   - Read password from st.session_state.login_password (set by text_input key)
   - Call login() from api_client (async wrapped in asyncio.run)
   - On success:
     - Set st.session_state.is_authenticated = True
     - Set st.session_state.access_token = result["access_token"]
     - Set st.session_state.refresh_token = result["refresh_token"]
     - Decode token and store in st.session_state.user_info
     - Set st.session_state.session_type = "authenticated"
   - On failure:
     - Set st.session_state.login_error = error message
   - NEVER call st.rerun() - let Streamlit auto-rerun after callback

2. decode_token_claims(token: str) -> dict:
   - Use pyjwt to decode without verification
   - Extract: sub (email), user_id, role, exp
   - Return dict with these fields

Critical patterns:
- Use on_click callbacks, NOT inline button logic
- Store error in session_state, display in page
- Let Streamlit's auto-rerun handle page refresh

Avoid:
- Calling st.rerun() in callback (causes infinite loop - Pitfall #2)
- Storing password in session_state
- Verifying JWT signature (already verified by backend)
  </action>
  <verify>
```bash
cd frontend && python -c "
from utils.auth import handle_login, decode_token_claims
print('Auth imports work')
# Test decode with fake token (should handle gracefully)
import jwt
fake_token = jwt.encode({'sub': 'test@test.com', 'user_id': '123', 'role': 'user', 'exp': 9999999999}, 'secret')
claims = decode_token_claims(fake_token)
assert claims['email'] == 'test@test.com', f'Email mismatch: {claims}'
print('Token decode works')
"
```
  </verify>
  <done>
- handle_login() callback reads inputs from session_state keys
- handle_login() calls api_client.login()
- handle_login() updates session_state on success
- handle_login() sets login_error on failure
- decode_token_claims() extracts email, user_id, role, exp
  </done>
</task>

<task type="auto">
  <name>Task 2: Create login page</name>
  <files>frontend/pages/login.py</files>
  <action>
Create login page following Pattern 3 from research.

Implementation requirements:

1. Page title: "Login" with lock icon

2. Form elements:
   - st.text_input for email with key="login_email"
   - st.text_input for password with type="password", key="login_password"
   - st.button "Login" with on_click=handle_login (NOT inline logic)

3. Error handling:
   - Check st.session_state.get("login_error")
   - Display with st.error() if present
   - Clear error after displaying (del st.session_state.login_error)

4. Navigation hint:
   - st.markdown divider
   - st.info with "Don't have an account? Go to Register page."

5. Redirect if already authenticated:
   - At top: if st.session_state.get("is_authenticated"): st.switch_page("pages/home.py")
   - Note: home.py doesn't exist yet, will be created in Plan 04

Key patterns:
- All form inputs use key= parameter to bind to session_state
- Button uses on_click callback, NOT inline if st.button()
- Error display happens AFTER button, checking session_state

Page structure:
```python
import streamlit as st
from utils.auth import handle_login

# Redirect if already logged in
if st.session_state.get("is_authenticated"):
    st.switch_page("pages/home.py")

st.title("üîê Login")

st.text_input("Email", key="login_email")
st.text_input("Password", type="password", key="login_password")
st.button("Login", on_click=handle_login)

# Display error if any
if st.session_state.get("login_error"):
    st.error(st.session_state.login_error)
    del st.session_state.login_error

st.markdown("---")
st.info("Don't have an account? Go to Register page.")
```

Avoid:
- Using if st.button("Login"): with inline login logic (infinite loop)
- Calling st.rerun() anywhere in page
- Processing form data inline instead of in callback
  </action>
  <verify>
```bash
cd frontend && python -c "
import sys
# Just verify syntax is correct
exec(open('pages/login.py').read().replace('import streamlit as st', 'class st: text_input=lambda *a,**k:None; button=lambda *a,**k:None; title=lambda *a:None; markdown=lambda *a:None; info=lambda *a:None; error=lambda *a:None; switch_page=lambda *a:None; session_state=type(\"obj\", (), {\"get\": lambda s,k: None})()'))
print('Login page syntax OK')
"
```
  </verify>
  <done>
- Login page displays title with icon
- Email and password inputs bound to session_state keys
- Login button uses on_click callback (NOT inline logic)
- Error from session_state displayed and cleared
- Navigation hint shown at bottom
  </done>
</task>

</tasks>

<verification>
1. Auth module imports:
   ```bash
   cd frontend && python -c "from utils.auth import handle_login, decode_token_claims; print('OK')"
   ```

2. Login page syntax valid:
   ```bash
   cd frontend && python -m py_compile pages/login.py && echo "Syntax OK"
   ```

3. Callback pattern used (no inline st.button logic):
   ```bash
   grep "on_click=handle_login" frontend/pages/login.py && echo "Callback pattern used"
   ```
</verification>

<success_criteria>
- pages/login.py exists with email/password form
- utils/auth.py exports handle_login callback
- Login button uses on_click callback (NOT if st.button inline)
- Error handling via session_state (no inline try/catch in page)
- No st.rerun() calls in login.py or handle_login callback
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation-authentication/07-02-SUMMARY.md`
</output>
