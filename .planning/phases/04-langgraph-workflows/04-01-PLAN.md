---
phase: 04-langgraph-workflows
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/config.py
  - backend/app/db/postgres_client.py
  - backend/app/db/checkpoint_store.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "PostgreSQL connection is established and healthy"
    - "LangGraph checkpointer tables exist in PostgreSQL"
    - "Workflow state can be persisted and retrieved across app restarts"
  artifacts:
    - path: "backend/app/db/postgres_client.py"
      provides: "Async PostgreSQL connection management"
      exports: ["get_postgres_pool", "close_postgres_pool"]
    - path: "backend/app/db/checkpoint_store.py"
      provides: "LangGraph AsyncPostgresSaver configuration"
      exports: ["get_checkpointer", "setup_checkpointer"]
  key_links:
    - from: "backend/app/db/checkpoint_store.py"
      to: "backend/app/db/postgres_client.py"
      via: "connection pool"
      pattern: "get_postgres_pool"
    - from: "backend/app/main.py"
      to: "backend/app/db/checkpoint_store.py"
      via: "startup event"
      pattern: "setup_checkpointer"
---

<objective>
Set up LangGraph infrastructure with PostgreSQL checkpointing for durable workflow state persistence.

Purpose: Enable LangGraph workflows to persist state across requests, supporting multi-turn complex queries (Success Criteria #4).
Output: Working PostgreSQL checkpointer that LangGraph workflows can use for state persistence.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-langgraph-workflows/04-RESEARCH.md

@backend/app/config.py
@backend/app/main.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LangGraph and PostgreSQL dependencies</name>
  <files>backend/requirements.txt, backend/app/config.py</files>
  <action>
1. Add to requirements.txt:
   - langgraph>=1.0
   - langgraph-checkpoint-postgres>=3.0.4
   - psycopg[binary]>=3.0
   - neo4j-graphrag-python

2. Add PostgreSQL configuration to Settings class in config.py:
   - POSTGRES_URI: str (default "postgresql://localhost:5432/ragapp")
   - POSTGRES_POOL_SIZE: int = 5
   - MEMORY_MAX_TOKENS: int = 4000
   - MEMORY_SUMMARIZATION_THRESHOLD: float = 0.75
  </action>
  <verify>
grep -q "langgraph>=1.0" backend/requirements.txt && grep -q "POSTGRES_URI" backend/app/config.py && echo "Dependencies and config added"
  </verify>
  <done>requirements.txt contains LangGraph dependencies; config.py has PostgreSQL and memory settings</done>
</task>

<task type="auto">
  <name>Task 2: Create PostgreSQL connection client</name>
  <files>backend/app/db/postgres_client.py</files>
  <action>
Create async PostgreSQL connection management module:

1. Import psycopg.AsyncConnectionPool
2. Create module-level _pool variable (Optional[AsyncConnectionPool])
3. Implement async get_postgres_pool() function:
   - Lazy initialization pattern (like other clients)
   - Use settings.POSTGRES_URI
   - Set pool size from settings.POSTGRES_POOL_SIZE
   - Return the pool
4. Implement async close_postgres_pool() function:
   - Close pool if initialized
   - Set _pool to None

NOTE: Do NOT use autocommit=True here; the checkpointer handles transactions.
  </action>
  <verify>
python -c "from backend.app.db.postgres_client import get_postgres_pool, close_postgres_pool; print('Import OK')"
  </verify>
  <done>postgres_client.py exports get_postgres_pool and close_postgres_pool functions</done>
</task>

<task type="auto">
  <name>Task 3: Create LangGraph checkpoint store</name>
  <files>backend/app/db/checkpoint_store.py, backend/app/main.py</files>
  <action>
1. Create checkpoint_store.py:
   - Import AsyncPostgresSaver from langgraph.checkpoint.postgres.aio
   - Import get_postgres_pool from postgres_client
   - Create module-level _checkpointer variable
   - Implement async get_checkpointer() -> AsyncPostgresSaver:
     * Get connection pool
     * Create AsyncPostgresSaver.from_conn_string(settings.POSTGRES_URI)
     * Return checkpointer
   - Implement async setup_checkpointer():
     * Get checkpointer
     * Call await checkpointer.setup() (CRITICAL: creates tables)
     * Log success message

2. Update main.py:
   - Add startup event to call setup_checkpointer()
   - Add shutdown event to call close_postgres_pool()
   - Wrap in try/except with logging for graceful failures

CRITICAL: setup_checkpointer() MUST be called at startup before any workflow execution.
  </action>
  <verify>
python -c "from backend.app.db.checkpoint_store import get_checkpointer, setup_checkpointer; print('Checkpoint store imports OK')"
  </verify>
  <done>checkpoint_store.py provides checkpointer; main.py calls setup on startup</done>
</task>

</tasks>

<verification>
```bash
# Verify imports work
cd /Users/apple/Desktop/RAGWithGraphStore
python -c "
from backend.app.config import settings
from backend.app.db.postgres_client import get_postgres_pool
from backend.app.db.checkpoint_store import get_checkpointer, setup_checkpointer
print('All imports successful')
print(f'Postgres URI configured: {bool(settings.POSTGRES_URI)}')
"

# Verify requirements
grep "langgraph" backend/requirements.txt
```
</verification>

<success_criteria>
- LangGraph and PostgreSQL dependencies added to requirements.txt
- PostgreSQL connection settings in config.py
- postgres_client.py provides async connection pool management
- checkpoint_store.py provides AsyncPostgresSaver with setup function
- main.py initializes checkpointer on startup
</success_criteria>

<output>
After completion, create `.planning/phases/04-langgraph-workflows/04-01-SUMMARY.md`
</output>
