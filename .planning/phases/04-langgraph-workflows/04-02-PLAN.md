---
phase: 04-langgraph-workflows
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/graphrag_service.py
  - backend/app/services/retrieval_service.py
autonomous: true

must_haves:
  truths:
    - "System can traverse Neo4j entity relationships across documents"
    - "Multi-hop graph traversal expands context beyond direct vector matches"
    - "Graph traversal queries are bounded (LIMIT, depth restrictions)"
  artifacts:
    - path: "backend/app/services/graphrag_service.py"
      provides: "GraphRAG multi-hop retrieval service"
      exports: ["expand_graph_context", "retrieve_with_graph_expansion"]
    - path: "backend/app/services/retrieval_service.py"
      provides: "Extended retrieval with optional graph expansion"
      contains: "graphrag"
  key_links:
    - from: "backend/app/services/graphrag_service.py"
      to: "backend/app/db/neo4j_client.py"
      via: "neo4j_driver session"
      pattern: "neo4j_driver\\.session"
    - from: "backend/app/services/retrieval_service.py"
      to: "backend/app/services/graphrag_service.py"
      via: "import"
      pattern: "from.*graphrag_service import"
---

<objective>
Implement GraphRAG multi-hop reasoning service using Neo4j graph traversal.

Purpose: Enable cross-document entity relationship traversal for richer context (Success Criteria #2).
Output: GraphRAG service that expands vector search results through entity relationship graphs.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-langgraph-workflows/04-RESEARCH.md

@backend/app/db/neo4j_client.py
@backend/app/services/retrieval_service.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GraphRAG multi-hop retrieval service</name>
  <files>backend/app/services/graphrag_service.py</files>
  <action>
Create GraphRAG service for multi-hop graph traversal:

1. Import neo4j_driver from db.neo4j_client, settings from config
2. Define MULTI_HOP_QUERY constant (Cypher query):
   ```
   MATCH (c:Chunk {id: $chunk_id})-[:PART_OF]->(d:Document)
   OPTIONAL MATCH (e:Entity)-[:APPEARS_IN]->(c)
   OPTIONAL MATCH (e)-[r:RELATES_TO]-(related:Entity)-[:APPEARS_IN]->(other_chunk:Chunk)
   WHERE other_chunk.id <> c.id
   RETURN c.id AS chunk_id,
          d.id AS document_id,
          d.filename AS filename,
          collect(DISTINCT {
              entity: e.name,
              type: labels(e)[0],
              related_entity: related.name,
              relation: type(r),
              related_chunk_id: other_chunk.id
          })[0..10] AS entity_relations
   LIMIT 50
   ```

3. Implement async expand_graph_context(chunk_ids: List[str], max_hops: int = 2) -> Dict:
   - For each chunk_id, run MULTI_HOP_QUERY
   - Collect entity relationships found
   - Return dict mapping chunk_id to list of related entities/chunks
   - CRITICAL: Always use LIMIT to prevent query explosion (Pitfall #3)

4. Implement async retrieve_with_graph_expansion(
       query: str,
       user_id: str,
       document_ids: Optional[List[str]] = None,
       max_results: int = 5
   ) -> Dict:
   - Call existing retrieval_service to get vector matches
   - Call expand_graph_context on retrieved chunk_ids
   - Merge graph context into results
   - Return enriched chunks with entity_relations field
  </action>
  <verify>
python -c "from backend.app.services.graphrag_service import expand_graph_context, retrieve_with_graph_expansion; print('GraphRAG service imports OK')"
  </verify>
  <done>graphrag_service.py exports expand_graph_context and retrieve_with_graph_expansion functions</done>
</task>

<task type="auto">
  <name>Task 2: Extend retrieval service with graph expansion option</name>
  <files>backend/app/services/retrieval_service.py</files>
  <action>
Extend existing retrieval service to support optional graph expansion:

1. Add import: from app.services.graphrag_service import expand_graph_context

2. Add new parameter to retrieve_relevant_context:
   - include_graph_context: bool = False

3. After Neo4j metadata enrichment, if include_graph_context is True:
   - Extract chunk_ids from enriched_chunks
   - Call expand_graph_context(chunk_ids)
   - Merge entity_relations into each chunk dict

4. Add new function retrieve_for_documents(
       query: str,
       user_id: str,
       document_ids: List[str],
       max_results: int = 5,
       include_graph_context: bool = True
   ) -> Dict:
   - Similar to retrieve_relevant_context but filters by document_ids
   - Modifies Qdrant filter to include document_id in filter
   - Always includes graph context (for document comparison use case)

This maintains backward compatibility while enabling graph-enhanced retrieval.
  </action>
  <verify>
python -c "
from backend.app.services.retrieval_service import retrieve_relevant_context, retrieve_for_documents
import inspect
sig = inspect.signature(retrieve_relevant_context)
assert 'include_graph_context' in sig.parameters, 'Missing include_graph_context param'
print('Retrieval service extended successfully')
"
  </verify>
  <done>retrieval_service.py supports include_graph_context parameter and has retrieve_for_documents function</done>
</task>

</tasks>

<verification>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore
python -c "
from backend.app.services.graphrag_service import expand_graph_context, retrieve_with_graph_expansion
from backend.app.services.retrieval_service import retrieve_relevant_context, retrieve_for_documents
print('All GraphRAG imports successful')
"
```
</verification>

<success_criteria>
- graphrag_service.py provides multi-hop graph traversal
- Graph queries use LIMIT to prevent explosion
- retrieval_service.py supports optional graph context expansion
- retrieve_for_documents function enables document-specific retrieval
- Existing retrieval behavior unchanged when include_graph_context=False
</success_criteria>

<output>
After completion, create `.planning/phases/04-langgraph-workflows/04-02-SUMMARY.md`
</output>
