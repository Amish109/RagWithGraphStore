---
phase: 02-multi-user-memory
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/config.py
  - backend/app/db/redis_client.py
  - backend/app/core/auth.py
  - backend/app/api/auth.py
  - backend/app/main.py
  - backend/pyproject.toml
autonomous: true

must_haves:
  truths:
    - "User receives both access_token and refresh_token on login"
    - "User can exchange refresh_token for new token pair"
    - "Used refresh token cannot be reused (single-use enforcement)"
    - "Logout invalidates tokens so they cannot be used again"
  artifacts:
    - path: "backend/app/db/redis_client.py"
      provides: "Redis connection pool and token blocklist operations"
      exports: ["get_redis", "close_redis", "add_token_to_blocklist", "is_token_blocklisted"]
    - path: "backend/app/core/auth.py"
      provides: "Refresh token creation and rotation"
      contains: "create_token_pair"
  key_links:
    - from: "backend/app/api/auth.py"
      to: "backend/app/db/redis_client.py"
      via: "Depends(get_redis) for token operations"
      pattern: "Depends\\(get_redis\\)"
    - from: "backend/app/api/auth.py"
      to: "backend/app/core/auth.py"
      via: "create_token_pair and validate_and_rotate_refresh_token"
      pattern: "validate_and_rotate_refresh_token"
---

<objective>
Add Redis for token management and implement refresh token rotation with single-use enforcement and token blocklist for secure logout.

Purpose: Enable extended user sessions without compromising security. Refresh token rotation detects token theft (if attacker uses stolen token, legitimate user's next refresh fails). Token blocklist prevents use of logged-out tokens.

Output: Redis client module, updated auth with token pairs, /refresh and improved /logout endpoints.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-user-memory/02-RESEARCH.md (Pattern 1: Redis Connection, Pattern 2: Refresh Token Rotation)
@.planning/phases/01-foundation-core-rag/01-02-SUMMARY.md (JWT auth foundation)
@backend/app/config.py
@backend/app/core/auth.py
@backend/app/api/auth.py
@backend/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Redis client with connection pool and token blocklist</name>
  <files>
    backend/app/config.py
    backend/app/db/redis_client.py
    backend/app/main.py
    backend/pyproject.toml
  </files>
  <action>
    1. Add to pyproject.toml dependencies: `redis = ">=5.0.0"`
    2. Add to config.py Settings class:
       - REDIS_URL: str = "redis://localhost:6379/0"
       - REDIS_MAX_CONNECTIONS: int = 50
       - REFRESH_TOKEN_EXPIRE_DAYS: int = 7
       - JTI_BLOCKLIST_EXPIRE_SECONDS: int = 604800 (7 days, match refresh lifetime)

    3. Create backend/app/db/redis_client.py:
       - Use `import redis.asyncio as redis` (NOT deprecated aioredis)
       - Create ConnectionPool from settings.REDIS_URL
       - Implement get_redis() -> async generator for FastAPI Depends
       - Implement close_redis() for shutdown cleanup
       - Implement add_token_to_blocklist(jti: str, redis_client) with TTL
       - Implement is_token_blocklisted(jti: str, redis_client) -> bool
       - Key format: "blocklist:{jti}"

    4. Update main.py lifespan:
       - Import close_redis from db.redis_client
       - Add await close_redis() in shutdown section

    CRITICAL: Use TTL on blocklist entries (setex) to prevent unbounded growth.
    CRITICAL: Use redis.asyncio, NOT aioredis (deprecated, merged into redis-py).
  </action>
  <verify>
    - pip install redis>=5.0.0 succeeds
    - python -c "from backend.app.db.redis_client import get_redis, close_redis, add_token_to_blocklist, is_token_blocklisted" succeeds
    - redis-cli ping returns PONG (requires local Redis or set REDIS_URL)
  </verify>
  <done>
    Redis client module created with connection pooling and blocklist operations using TTL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement refresh token rotation with single-use enforcement</name>
  <files>
    backend/app/core/auth.py
    backend/app/api/auth.py
    backend/app/models/schemas.py
  </files>
  <action>
    1. Update backend/app/core/auth.py:
       - Add imports: secrets, hashlib
       - Create create_token_pair(user_email: str, user_id: str) -> Tuple[str, str, str]:
         - Generate jti using secrets.token_urlsafe(32)
         - Create access_token with {"sub": user_email, "user_id": user_id, "jti": jti}
         - Create refresh_token with {"sub": user_email, "user_id": user_id, "jti": jti, "type": "refresh", "exp": now + REFRESH_TOKEN_EXPIRE_DAYS}
         - Return (access_token, refresh_token, jti)
       - Add hash_refresh_token(token: str) -> str using SHA-256
       - Add store_refresh_token(user_id: str, jti: str, token_hash: str, redis_client) -> None:
         - Key: "refresh:{user_id}:{jti}", Value: token_hash, TTL: REFRESH_TOKEN_EXPIRE_DAYS * 86400
       - Add validate_and_rotate_refresh_token(refresh_token: str, redis_client) -> Optional[Tuple[str, str, str]]:
         - Decode token, verify type=="refresh"
         - Check Redis for stored hash at "refresh:{user_id}:{jti}"
         - If not found or hash mismatch, return None (token already used or invalid)
         - Delete old key (single-use)
         - Create new token pair, store new refresh token
         - Return new (access_token, refresh_token, jti)

    2. Update backend/app/models/schemas.py:
       - Add TokenPair schema: access_token: str, refresh_token: str, token_type: str = "bearer"
       - Add RefreshRequest schema: refresh_token: str

    3. Update backend/app/api/auth.py:
       - Modify /login to use create_token_pair, store refresh token in Redis, return TokenPair
       - Add POST /refresh endpoint:
         - Accept RefreshRequest body
         - Call validate_and_rotate_refresh_token
         - Return new TokenPair or 401 if invalid/reused
       - Modify /logout to:
         - Get jti from current token
         - Add jti to blocklist using add_token_to_blocklist
         - Return success message
       - Add Depends(get_redis) where needed

    CRITICAL: Each refresh token is SINGLE-USE. Delete from Redis after use.
    CRITICAL: Hash refresh tokens with SHA-256 before storing (never store raw tokens).
  </action>
  <verify>
    - curl POST /api/v1/auth/login returns access_token AND refresh_token
    - curl POST /api/v1/auth/refresh with valid refresh_token returns new token pair
    - Second call with SAME refresh_token returns 401 (single-use)
    - curl POST /api/v1/auth/logout with Authorization header succeeds
    - After logout, using same access_token returns 401
  </verify>
  <done>
    Refresh token rotation implemented with single-use enforcement. Login returns token pair. /refresh exchanges refresh token for new pair. /logout adds token to blocklist.
  </done>
</task>

</tasks>

<verification>
Run the following commands to verify Phase 2 Plan 01 completion:

```bash
# 1. Dependencies installed
pip show redis | grep Version

# 2. Redis connection works
cd backend && python -c "
import asyncio
from app.db.redis_client import get_redis, close_redis, add_token_to_blocklist, is_token_blocklisted

async def test():
    redis = await anext(get_redis())
    # Test blocklist
    await add_token_to_blocklist('test_jti_123', redis)
    blocked = await is_token_blocklisted('test_jti_123', redis)
    print(f'Token blocked: {blocked}')
    assert blocked == True
    # Cleanup
    await redis.delete('blocklist:test_jti_123')
    await close_redis()
    print('Redis test passed')

asyncio.run(test())
"

# 3. Auth functions work
cd backend && python -c "
from app.core.auth import create_token_pair, hash_refresh_token
access, refresh, jti = create_token_pair('test@example.com', 'user_123')
print(f'Access token: {access[:50]}...')
print(f'Refresh token: {refresh[:50]}...')
print(f'JTI: {jti}')
print(f'Hash: {hash_refresh_token(refresh)[:16]}...')
"

# 4. API endpoints (requires running server)
# Start server: uvicorn backend.app.main:app --reload
# Test login returns token pair
# Test refresh with valid token
# Test refresh with same token fails (single-use)
# Test logout invalidates token
```
</verification>

<success_criteria>
1. Redis client created with async connection pool using redis.asyncio
2. Token blocklist uses TTL to auto-expire entries
3. Login returns both access_token and refresh_token
4. /refresh endpoint rotates tokens (returns new pair, invalidates old)
5. Same refresh token cannot be used twice (401 on reuse)
6. /logout adds token JTI to blocklist
7. Blocklisted tokens rejected on subsequent requests
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-user-memory/02-01-SUMMARY.md`
</output>
