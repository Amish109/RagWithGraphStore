---
phase: 02-multi-user-memory
plan: 04
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - backend/app/config.py
  - backend/app/services/memory_service.py
  - backend/app/api/memory.py
  - backend/app/main.py
  - backend/app/db/mem0_client.py
autonomous: true

must_haves:
  truths:
    - "User can add arbitrary facts to their private memory"
    - "User can search their memories with natural language query"
    - "Memories are isolated by user_id - users cannot see others' memories"
    - "Conversation history persists within session"
  artifacts:
    - path: "backend/app/services/memory_service.py"
      provides: "Memory CRUD operations with user isolation"
      exports: ["add_user_memory", "search_user_memories", "get_conversation_history", "add_conversation_turn"]
    - path: "backend/app/api/memory.py"
      provides: "Memory REST endpoints"
      exports: ["router"]
  key_links:
    - from: "backend/app/services/memory_service.py"
      to: "backend/app/db/mem0_client.py"
      via: "get_mem0() for memory operations"
      pattern: "get_mem0\\(\\)"
    - from: "backend/app/api/memory.py"
      to: "backend/app/services/memory_service.py"
      via: "Service function imports"
      pattern: "from app.services.memory_service import"
---

<objective>
Create memory service and API endpoints for Mem0-based user memory management. Users can add facts to private memory, search memories, and maintain conversation history within sessions.

Purpose: Enable personalized RAG responses that incorporate user's private facts and conversation context. Mem0 handles memory storage with user_id isolation. Conversations persist across browser refresh (session-based).

Output: Memory service with Mem0 operations, REST API for memory CRUD.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-user-memory/02-RESEARCH.md (Pattern 7: Mem0 Memory Operations)
@.planning/phases/01-foundation-core-rag/01-05-SUMMARY.md (Mem0 client configured)
@backend/app/db/mem0_client.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory service with user-isolated operations</name>
  <files>
    backend/app/config.py
    backend/app/services/memory_service.py
    backend/app/db/mem0_client.py
  </files>
  <action>
    1. Add to backend/app/config.py Settings:
       - SHARED_MEMORY_USER_ID: str = "__shared__"  # Sentinel for company memory

    2. Create backend/app/services/memory_service.py:
       ```python
       from typing import List, Dict, Optional
       from datetime import datetime, timezone
       from app.db.mem0_client import get_mem0
       from app.config import settings

       async def add_user_memory(
           user_id: str,
           content: str,
           metadata: Optional[dict] = None
       ) -> dict:
           """Add a memory for a specific user (MEM-04).

           User can add arbitrary facts to their private memory.
           These influence future query responses.
           """
           memory = get_mem0()

           result = memory.add(
               messages=content,
               user_id=user_id,
               metadata={
                   **(metadata or {}),
                   "type": "fact",
                   "added_at": datetime.now(timezone.utc).isoformat()
               }
           )

           return result

       async def search_user_memories(
           user_id: str,
           query: str,
           limit: int = 5
       ) -> List[dict]:
           """Search memories for a user.

           Returns relevant memories based on semantic search.
           """
           memory = get_mem0()

           results = memory.search(
               query=query,
               user_id=user_id,
               limit=limit
           )

           return results.get("results", []) if isinstance(results, dict) else results

       async def get_user_memories(
           user_id: str,
           limit: int = 50
       ) -> List[dict]:
           """Get all memories for a user."""
           memory = get_mem0()

           results = memory.get_all(user_id=user_id, limit=limit)

           return results if isinstance(results, list) else results.get("results", [])

       async def delete_user_memory(
           user_id: str,
           memory_id: str
       ) -> bool:
           """Delete a specific memory.

           NOTE: Mem0 has known bug where deletion doesn't clean Neo4j.
           We handle orphan cleanup in scheduled job (Plan 06).
           """
           memory = get_mem0()

           try:
               memory.delete(memory_id)
               return True
           except Exception:
               return False

       async def add_conversation_turn(
           user_id: str,
           session_id: str,
           role: str,  # "user" or "assistant"
           content: str
       ) -> dict:
           """Add a conversation turn to session history (MEM-01).

           Tracks conversation within a session for context.
           """
           memory = get_mem0()

           result = memory.add(
               messages=content,
               user_id=user_id,
               metadata={
                   "type": "conversation",
                   "session_id": session_id,
                   "role": role,
                   "timestamp": datetime.now(timezone.utc).isoformat()
               }
           )

           return result

       async def get_conversation_history(
           user_id: str,
           session_id: str,
           limit: int = 20
       ) -> List[dict]:
           """Get conversation history for a session (MEM-01).

           Returns recent conversation turns in chronological order.
           """
           memory = get_mem0()

           # Get all user memories
           all_memories = memory.get_all(user_id=user_id, limit=100)
           memories = all_memories if isinstance(all_memories, list) else all_memories.get("results", [])

           # Filter by session_id and type=conversation
           session_memories = [
               m for m in memories
               if m.get("metadata", {}).get("session_id") == session_id
               and m.get("metadata", {}).get("type") == "conversation"
           ]

           # Sort by timestamp and limit
           session_memories.sort(key=lambda m: m.get("metadata", {}).get("timestamp", ""))

           return session_memories[-limit:]

       async def get_user_preferences(user_id: str) -> List[dict]:
           """Get user preferences from memory (MEM-03).

           Returns memories marked as preferences for cross-session personalization.
           """
           memory = get_mem0()

           all_memories = memory.get_all(user_id=user_id, limit=100)
           memories = all_memories if isinstance(all_memories, list) else all_memories.get("results", [])

           # Filter for preference-type memories
           preferences = [
               m for m in memories
               if m.get("metadata", {}).get("type") in ["preference", "fact"]
           ]

           return preferences
       ```

    CRITICAL: Always use user_id parameter for isolation (Pitfall #1).
    CRITICAL: Include type and timestamp in metadata for filtering.
  </action>
  <verify>
    python -c "
from backend.app.services.memory_service import (
    add_user_memory, search_user_memories, get_user_memories,
    add_conversation_turn, get_conversation_history
)
print('Memory service functions:', [
    'add_user_memory', 'search_user_memories', 'get_user_memories',
    'add_conversation_turn', 'get_conversation_history'
])
print('Memory service OK')
"
  </verify>
  <done>
    Memory service created with user-isolated operations for facts, conversation history, and preferences.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create memory API endpoints</name>
  <files>
    backend/app/api/memory.py
    backend/app/main.py
    backend/app/models/schemas.py
  </files>
  <action>
    1. Add to backend/app/models/schemas.py:
       ```python
       class MemoryAddRequest(BaseModel):
           content: str
           metadata: Optional[dict] = None

       class MemorySearchRequest(BaseModel):
           query: str
           limit: int = 5

       class MemoryResponse(BaseModel):
           id: str
           memory: str
           metadata: Optional[dict] = None
           score: Optional[float] = None

       class MemoryListResponse(BaseModel):
           memories: List[MemoryResponse]
           count: int
       ```

    2. Create backend/app/api/memory.py:
       ```python
       from fastapi import APIRouter, Depends, HTTPException, status
       from typing import List
       from app.core.security import get_current_user_optional
       from app.models.schemas import (
           UserContext, MemoryAddRequest, MemorySearchRequest,
           MemoryResponse, MemoryListResponse
       )
       from app.services.memory_service import (
           add_user_memory, search_user_memories, get_user_memories,
           delete_user_memory
       )

       router = APIRouter(prefix="/memory", tags=["memory"])

       @router.post("/", response_model=dict)
       async def add_memory(
           request: MemoryAddRequest,
           current_user: UserContext = Depends(get_current_user_optional)
       ):
           """Add a fact to user's private memory (MEM-04).

           Authenticated users: stored permanently
           Anonymous users: stored with session ID (expires with session)
           """
           result = await add_user_memory(
               user_id=current_user.id,
               content=request.content,
               metadata=request.metadata
           )

           return {
               "status": "added",
               "memory_id": result.get("id") if isinstance(result, dict) else str(result),
               "user_id": current_user.id
           }

       @router.post("/search", response_model=MemoryListResponse)
       async def search_memories(
           request: MemorySearchRequest,
           current_user: UserContext = Depends(get_current_user_optional)
       ):
           """Search user's memories with natural language query."""
           results = await search_user_memories(
               user_id=current_user.id,
               query=request.query,
               limit=request.limit
           )

           memories = [
               MemoryResponse(
                   id=m.get("id", ""),
                   memory=m.get("memory", ""),
                   metadata=m.get("metadata"),
                   score=m.get("score")
               )
               for m in results
           ]

           return MemoryListResponse(memories=memories, count=len(memories))

       @router.get("/", response_model=MemoryListResponse)
       async def list_memories(
           limit: int = 50,
           current_user: UserContext = Depends(get_current_user_optional)
       ):
           """List all user's memories."""
           results = await get_user_memories(
               user_id=current_user.id,
               limit=limit
           )

           memories = [
               MemoryResponse(
                   id=m.get("id", ""),
                   memory=m.get("memory", ""),
                   metadata=m.get("metadata")
               )
               for m in results
           ]

           return MemoryListResponse(memories=memories, count=len(memories))

       @router.delete("/{memory_id}")
       async def delete_memory(
           memory_id: str,
           current_user: UserContext = Depends(get_current_user_optional)
       ):
           """Delete a specific memory."""
           # Note: Mem0 doesn't enforce ownership - we trust user_id from auth
           success = await delete_user_memory(
               user_id=current_user.id,
               memory_id=memory_id
           )

           if not success:
               raise HTTPException(
                   status_code=status.HTTP_404_NOT_FOUND,
                   detail="Memory not found or already deleted"
               )

           return {"status": "deleted", "memory_id": memory_id}
       ```

    3. Update backend/app/main.py:
       - Import memory router: `from app.api.memory import router as memory_router`
       - Include router: `app.include_router(memory_router, prefix="/api/v1")`

    NOTE: Uses get_current_user_optional so both authenticated and anonymous can use.
    NOTE: Anonymous users' memories tied to their session ID.
  </action>
  <verify>
    # Start server and test:
    # curl POST /api/v1/memory -d '{"content": "I prefer concise answers"}'
    # curl POST /api/v1/memory/search -d '{"query": "preference"}'
    # curl GET /api/v1/memory
    # curl DELETE /api/v1/memory/{id}
  </verify>
  <done>
    Memory API endpoints created for adding, searching, listing, and deleting user memories.
  </done>
</task>

</tasks>

<verification>
Run the following commands to verify Phase 2 Plan 04 completion:

```bash
# 1. Memory service functions exist
cd backend && python -c "
from app.services.memory_service import (
    add_user_memory, search_user_memories, get_user_memories,
    add_conversation_turn, get_conversation_history, get_user_preferences
)
print('All memory service functions available')
"

# 2. API router registered
cd backend && python -c "
from app.api.memory import router
print('Routes:', [r.path for r in router.routes])
"

# 3. Integration test (requires Mem0 backend running)
# curl -X POST http://localhost:8000/api/v1/memory \
#   -H "Content-Type: application/json" \
#   -H "Authorization: Bearer $TOKEN" \
#   -d '{"content": "My favorite color is blue"}'

# curl -X POST http://localhost:8000/api/v1/memory/search \
#   -H "Content-Type: application/json" \
#   -H "Authorization: Bearer $TOKEN" \
#   -d '{"query": "color preference"}'

# curl http://localhost:8000/api/v1/memory \
#   -H "Authorization: Bearer $TOKEN"
```
</verification>

<success_criteria>
1. Memory service has add_user_memory, search_user_memories, get_user_memories
2. Memory service has add_conversation_turn, get_conversation_history
3. All operations use user_id for isolation
4. POST /memory adds fact to user's memory
5. POST /memory/search returns relevant memories
6. GET /memory lists all user memories
7. DELETE /memory/{id} removes specific memory
8. Both authenticated and anonymous users can use endpoints
9. Anonymous users' memories tied to their session ID
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-user-memory/02-04-SUMMARY.md`
</output>
