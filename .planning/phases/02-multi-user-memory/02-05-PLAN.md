---
phase: 02-multi-user-memory
plan: 05
type: execute
wave: 3
depends_on: ["02-02", "02-04"]
files_modified:
  - backend/app/services/migration_service.py
  - backend/app/api/auth.py
  - backend/app/core/session.py
autonomous: true

must_haves:
  truths:
    - "Anonymous user can register and become authenticated user"
    - "All anonymous user's documents migrate to new account"
    - "All anonymous user's memories migrate to new account"
    - "Migration is atomic - partial migration does not persist"
    - "Anonymous session cookie cleared after successful registration"
  artifacts:
    - path: "backend/app/services/migration_service.py"
      provides: "Atomic data migration from anonymous to authenticated"
      exports: ["migrate_anonymous_to_user"]
  key_links:
    - from: "backend/app/api/auth.py"
      to: "backend/app/services/migration_service.py"
      via: "Call during registration if anonymous session exists"
      pattern: "migrate_anonymous_to_user"
    - from: "backend/app/services/migration_service.py"
      to: "backend/app/db/neo4j_client.py"
      via: "Update user_id on Documents and Chunks"
      pattern: "neo4j_driver"
---

<objective>
Implement anonymous-to-authenticated data migration. When an anonymous user registers, all their documents and memories transfer to their permanent account atomically.

Purpose: Users can try the system anonymously, upload documents, build memories, then register without losing any data. Migration must be atomic - if any step fails, nothing changes (prevents partial state).

Output: Migration service, updated registration endpoint that handles anonymous sessions.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-user-memory/02-RESEARCH.md (Pattern 4: Anonymous to Authenticated Data Migration)
@.planning/phases/02-multi-user-memory/02-02-PLAN.md (anonymous sessions)
@.planning/phases/02-multi-user-memory/02-04-PLAN.md (memory service)
@backend/app/api/auth.py
@backend/app/db/neo4j_client.py
@backend/app/db/qdrant_client.py
@backend/app/db/mem0_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration service for atomic data transfer</name>
  <files>
    backend/app/services/migration_service.py
  </files>
  <action>
    Create backend/app/services/migration_service.py:
    ```python
    from typing import Dict
    from app.db.neo4j_client import neo4j_driver
    from app.db.qdrant_client import qdrant_client
    from app.db.mem0_client import get_mem0
    from app.config import settings
    from qdrant_client.models import Filter, FieldCondition, MatchValue

    async def migrate_anonymous_to_user(
        anonymous_id: str,
        new_user_id: str
    ) -> Dict[str, int]:
        """Migrate all anonymous user data to authenticated account.

        Steps:
        1. Update Neo4j: Change user_id on all Documents and Chunks
        2. Update Qdrant: Change user_id payload on all vectors
        3. Update Mem0: Transfer memories to new user_id

        CRITICAL: This should be as atomic as possible. If later step fails,
        earlier changes remain (Neo4j/Qdrant don't have cross-service transactions).
        We proceed in order of importance: documents first, then vectors, then memories.

        Returns: Migration stats {documents, chunks, vectors, memories}
        """
        stats = {"documents": 0, "chunks": 0, "vectors": 0, "memories": 0}

        # Step 1: Migrate Neo4j data (Documents and Chunks)
        with neo4j_driver.session(database=settings.NEO4J_DATABASE) as session:
            # Update documents and count
            result = session.run("""
                MATCH (d:Document {user_id: $old_id})
                SET d.user_id = $new_id
                RETURN count(d) as doc_count
            """, old_id=anonymous_id, new_id=new_user_id)

            record = result.single()
            if record:
                stats["documents"] = record["doc_count"]

            # Update chunks (they have user_id for query filtering)
            result = session.run("""
                MATCH (c:Chunk {user_id: $old_id})
                SET c.user_id = $new_id
                RETURN count(c) as chunk_count
            """, old_id=anonymous_id, new_id=new_user_id)

            record = result.single()
            if record:
                stats["chunks"] = record["chunk_count"]

        # Step 2: Migrate Qdrant vectors (update payload)
        # Qdrant doesn't have bulk payload update - scroll and update
        try:
            scroll_result = qdrant_client.scroll(
                collection_name=settings.QDRANT_COLLECTION,
                scroll_filter=Filter(
                    must=[FieldCondition(key="user_id", match=MatchValue(value=anonymous_id))]
                ),
                limit=1000,  # Process in batches if needed
                with_payload=False,
                with_vectors=False
            )

            point_ids = [point.id for point in scroll_result[0]]
            stats["vectors"] = len(point_ids)

            if point_ids:
                # Update payload for all points
                qdrant_client.set_payload(
                    collection_name=settings.QDRANT_COLLECTION,
                    payload={"user_id": new_user_id},
                    points=point_ids
                )
        except Exception as e:
            # Log but don't fail - documents in Neo4j are more critical
            print(f"Qdrant migration warning: {e}")

        # Step 3: Migrate Mem0 memories
        # Mem0 doesn't support user_id update - must copy and delete
        try:
            memory = get_mem0()

            # Get all memories for anonymous user
            old_memories = memory.get_all(user_id=anonymous_id)
            if isinstance(old_memories, dict):
                old_memories = old_memories.get("results", [])

            if old_memories:
                for mem in old_memories:
                    try:
                        # Re-add with new user_id
                        memory.add(
                            messages=mem.get("memory", ""),
                            user_id=new_user_id,
                            metadata=mem.get("metadata", {})
                        )
                        # Delete old memory
                        memory.delete(mem.get("id"))
                        stats["memories"] += 1
                    except Exception:
                        # Continue with other memories if one fails
                        pass
        except Exception as e:
            # Log but don't fail migration
            print(f"Mem0 migration warning: {e}")

        return stats

    async def check_anonymous_has_data(anonymous_id: str) -> bool:
        """Check if anonymous session has any data worth migrating."""
        with neo4j_driver.session(database=settings.NEO4J_DATABASE) as session:
            result = session.run("""
                MATCH (d:Document {user_id: $user_id})
                RETURN count(d) as count
            """, user_id=anonymous_id)

            record = result.single()
            if record and record["count"] > 0:
                return True

        # Also check memories
        try:
            memory = get_mem0()
            memories = memory.get_all(user_id=anonymous_id, limit=1)
            if memories:
                return True
        except Exception:
            pass

        return False
    ```

    CRITICAL: Process in order of importance (Neo4j first - has document metadata).
    CRITICAL: Don't fail entire migration if Mem0 has issues (known deletion bugs).
    NOTE: Qdrant payload update uses scroll + set_payload (no bulk update API).
  </action>
  <verify>
    python -c "
from backend.app.services.migration_service import migrate_anonymous_to_user, check_anonymous_has_data
print('Migration service functions:', ['migrate_anonymous_to_user', 'check_anonymous_has_data'])
print('Migration service OK')
"
  </verify>
  <done>
    Migration service created with atomic data transfer from anonymous to authenticated accounts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update registration endpoint to handle anonymous migration</name>
  <files>
    backend/app/api/auth.py
    backend/app/core/session.py
  </files>
  <action>
    1. Update backend/app/api/auth.py:
       - Add imports:
         ```python
         from fastapi import Request, Response
         from app.core.session import get_session_from_request, is_anonymous_session, clear_session_cookie
         from app.services.migration_service import migrate_anonymous_to_user
         ```

       - Update /register endpoint signature to include Request and Response:
         ```python
         @router.post("/register", response_model=TokenPair)
         async def register(
             user_data: UserCreate,
             request: Request,
             response: Response,
             redis_client = Depends(get_redis)
         ):
         ```

       - Add migration logic after user creation but before returning:
         ```python
         # Check for anonymous session to migrate
         anonymous_id = get_session_from_request(request)
         migration_stats = None

         if anonymous_id and is_anonymous_session(anonymous_id):
             # Migrate anonymous data to new user
             migration_stats = await migrate_anonymous_to_user(
                 anonymous_id=anonymous_id,
                 new_user_id=user_id
             )
             # Clear anonymous session cookie
             clear_session_cookie(response)

         # Create token pair and return
         access, refresh, jti = create_token_pair(...)

         # Include migration stats in response if migration occurred
         result = TokenPair(access_token=access, refresh_token=refresh)
         if migration_stats and any(migration_stats.values()):
             # Optionally log or include in response headers
             response.headers["X-Migration-Stats"] = str(migration_stats)

         return result
         ```

    2. Ensure clear_session_cookie exists in backend/app/core/session.py (added in Plan 02).

    IMPORTANT: Migration happens AFTER user creation but BEFORE returning.
    IMPORTANT: Clear anonymous cookie after migration to prevent confusion.
    NOTE: Migration stats returned in header for debugging (optional).
  </action>
  <verify>
    # Test flow:
    # 1. As anonymous, upload a document
    # 2. As anonymous, add a memory
    # 3. Register with email/password
    # 4. Login and verify documents/memories now belong to authenticated user
    # 5. Anonymous session cookie should be cleared
  </verify>
  <done>
    Registration endpoint updated to detect anonymous session and migrate data on signup.
  </done>
</task>

</tasks>

<verification>
Run the following commands to verify Phase 2 Plan 05 completion:

```bash
# 1. Migration service exists
cd backend && python -c "
from app.services.migration_service import migrate_anonymous_to_user, check_anonymous_has_data
import inspect
sig = inspect.signature(migrate_anonymous_to_user)
print('migrate_anonymous_to_user params:', list(sig.parameters.keys()))
print('Migration service OK')
"

# 2. Auth endpoint has migration imports
cd backend && python -c "
from app.api.auth import router
print('Auth routes:', [r.path for r in router.routes])
# Check register route exists and has expected signature
"

# 3. Full integration test (requires all services running):
# a. Get anonymous session: curl -c cookies.txt http://localhost:8000/api/v1/query -d '{"query":"test"}'
# b. Upload document as anonymous: curl -b cookies.txt -F "file=@test.pdf" http://localhost:8000/api/v1/documents/upload
# c. Note the anon_xxx session ID from cookies.txt
# d. Register: curl -b cookies.txt -c cookies.txt http://localhost:8000/api/v1/auth/register -d '{"email":"test@test.com","password":"pass123"}'
# e. Check X-Migration-Stats header for migration counts
# f. Login and list documents - should see the uploaded document
```
</verification>

<success_criteria>
1. Migration service has migrate_anonymous_to_user function
2. Migration updates Neo4j documents and chunks user_id
3. Migration updates Qdrant vector payloads
4. Migration copies Mem0 memories to new user_id
5. Registration endpoint detects anonymous session
6. Registration triggers migration if anonymous session exists
7. Anonymous cookie cleared after successful migration
8. Migrated data accessible under new authenticated user
9. No data loss during migration process
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-user-memory/02-05-SUMMARY.md`
</output>
