---
phase: 02-multi-user-memory
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/app/core/rbac.py
  - backend/app/models/user.py
  - backend/app/core/security.py
  - backend/app/core/auth.py
autonomous: true

must_haves:
  truths:
    - "Users have 'user' role by default"
    - "Admin role can be assigned to users"
    - "Role is included in JWT token payload"
    - "Admin-only endpoints return 403 for non-admin users"
  artifacts:
    - path: "backend/app/core/rbac.py"
      provides: "Role enum and RoleChecker dependency"
      exports: ["Role", "RoleChecker", "require_admin", "require_user"]
    - path: "backend/app/models/user.py"
      provides: "User CRUD with role field"
      contains: "role"
  key_links:
    - from: "backend/app/core/rbac.py"
      to: "backend/app/core/security.py"
      via: "Depends(get_current_user) for role checking"
      pattern: "Depends\\(get_current_user\\)"
    - from: "backend/app/core/auth.py"
      to: "backend/app/core/rbac.py"
      via: "Role enum used in token payload"
      pattern: "from app.core.rbac import Role"
---

<objective>
Implement role-based access control (RBAC) with user and admin roles using FastAPI dependency injection. Admins can manage shared memory while regular users have standard access.

Purpose: Enable admin-only features like shared memory management. Role checking via dependencies ensures consistent enforcement across all endpoints. JWT contains role for fast authorization checks.

Output: RBAC module with Role enum and RoleChecker dependency, updated user model with role field.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-user-memory/02-RESEARCH.md (Pattern 6: Role-Based Access Control)
@.planning/phases/01-foundation-core-rag/01-02-SUMMARY.md (auth foundation)
@.planning/phases/02-multi-user-memory/02-01-PLAN.md (refresh tokens, must include role in token)
@backend/app/models/user.py
@backend/app/core/auth.py
@backend/app/core/security.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RBAC module with Role enum and RoleChecker dependency</name>
  <files>
    backend/app/core/rbac.py
  </files>
  <action>
    Create backend/app/core/rbac.py:
    ```python
    from enum import Enum
    from fastapi import Depends, HTTPException, status
    from app.core.security import get_current_user
    from app.models.schemas import UserContext

    class Role(str, Enum):
        """User roles for access control."""
        USER = "user"
        ADMIN = "admin"
        ANONYMOUS = "anonymous"

    class RoleChecker:
        """Dependency for role-based access control.

        Usage:
        @router.post("/admin-only")
        async def admin_endpoint(user: UserContext = Depends(RoleChecker([Role.ADMIN]))):
            ...

        @router.post("/authenticated-only")
        async def auth_endpoint(user: UserContext = Depends(RoleChecker([Role.USER, Role.ADMIN]))):
            ...
        """
        def __init__(self, allowed_roles: list[Role]):
            self.allowed_roles = allowed_roles

        async def __call__(self, user: UserContext = Depends(get_current_user)) -> UserContext:
            # Anonymous users have role="anonymous"
            user_role = Role(user.role) if user.role in [r.value for r in Role] else Role.ANONYMOUS

            if user_role not in self.allowed_roles:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Insufficient permissions. Required: {[r.value for r in self.allowed_roles]}"
                )

            return user

    # Convenience dependencies
    require_admin = RoleChecker([Role.ADMIN])
    require_user = RoleChecker([Role.USER, Role.ADMIN])  # Admin can do user things
    require_authenticated = RoleChecker([Role.USER, Role.ADMIN])  # Alias for clarity
    ```

    NOTE: RoleChecker uses get_current_user (not optional), so it requires authentication.
    Anonymous endpoints should not use RoleChecker - they use get_current_user_optional.
  </action>
  <verify>
    python -c "
from backend.app.core.rbac import Role, RoleChecker, require_admin, require_user
print('Roles:', [r.value for r in Role])
print('require_admin:', require_admin)
print('require_user:', require_user)
print('RBAC module OK')
"
  </verify>
  <done>
    RBAC module created with Role enum and RoleChecker dependency for admin/user role enforcement.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update user model and auth to include role</name>
  <files>
    backend/app/models/user.py
    backend/app/core/auth.py
    backend/app/core/security.py
  </files>
  <action>
    1. Update backend/app/models/user.py:
       - Update create_user function to accept role parameter with default "user":
         ```python
         def create_user(email: str, hashed_password: str, user_id: str, role: str = "user") -> dict:
         ```
       - Update Neo4j CREATE query to include role:
         ```cypher
         CREATE (u:User {
             id: $id,
             email: $email,
             hashed_password: $hashed_password,
             role: $role,
             created_at: datetime()
         })
         ```
       - Update get_user_by_email to return role field (already returns all fields if using RETURN u)
       - Add get_user_by_id function if not exists

    2. Update backend/app/core/auth.py:
       - Import Role from rbac: `from app.core.rbac import Role`
       - Update create_token_pair to accept role parameter:
         ```python
         def create_token_pair(user_email: str, user_id: str, role: str = "user") -> Tuple[str, str, str]:
         ```
       - Include role in both access_token and refresh_token payloads:
         ```python
         {"sub": user_email, "user_id": user_id, "role": role, "jti": jti}
         ```

    3. Update backend/app/core/security.py:
       - In get_current_user, extract role from token payload:
         ```python
         role = payload.get("role", "user")
         ```
       - Return role in UserContext:
         ```python
         return UserContext(
             id=user["id"],
             email=user["email"],
             is_anonymous=False,
             role=role
         )
         ```

    4. Update backend/app/api/auth.py:
       - In /login, pass user role to create_token_pair:
         ```python
         access, refresh, jti = create_token_pair(user["email"], user["id"], user.get("role", "user"))
         ```

    CRITICAL: Role must be in JWT for fast authorization without database lookup.
    NOTE: Default role is "user", admin role assigned manually (e.g., via database or admin endpoint).
  </action>
  <verify>
    python -c "
from backend.app.core.auth import create_token_pair, decode_access_token
# Test token includes role
access, refresh, jti = create_token_pair('test@example.com', 'user_123', 'admin')
payload = decode_access_token(access)
print(f'Token payload: {payload}')
assert payload.get('role') == 'admin', 'Role must be in token'
print('Auth role OK')
"
  </verify>
  <done>
    User model includes role field, JWT tokens contain role, security dependency extracts role for authorization.
  </done>
</task>

</tasks>

<verification>
Run the following commands to verify Phase 2 Plan 03 completion:

```bash
# 1. RBAC module works
cd backend && python -c "
from app.core.rbac import Role, RoleChecker, require_admin, require_user
print('Roles:', list(Role))
print('RBAC OK')
"

# 2. User model has role
cd backend && python -c "
import inspect
from app.models.user import create_user
sig = inspect.signature(create_user)
print('create_user params:', list(sig.parameters.keys()))
assert 'role' in sig.parameters, 'role parameter must exist'
print('User model OK')
"

# 3. Token includes role
cd backend && python -c "
from app.core.auth import create_token_pair, decode_access_token
access, refresh, jti = create_token_pair('test@test.com', 'uid', 'admin')
payload = decode_access_token(access)
assert payload['role'] == 'admin'
print('Token role OK')
"

# 4. API test (requires running server)
# Register user, login, verify token contains role
# Create admin user in DB, login, verify role=admin in token
# Call admin-only endpoint with user token -> 403
# Call admin-only endpoint with admin token -> success
```
</verification>

<success_criteria>
1. Role enum defines USER, ADMIN, ANONYMOUS values
2. RoleChecker dependency validates user role against allowed roles
3. require_admin convenience dependency restricts to admin role
4. require_user allows both user and admin roles
5. User model stores role field in Neo4j (default: "user")
6. JWT tokens include role in payload
7. Role extracted from token in get_current_user
8. Admin-only endpoints return 403 for non-admin users
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-user-memory/02-03-SUMMARY.md`
</output>
