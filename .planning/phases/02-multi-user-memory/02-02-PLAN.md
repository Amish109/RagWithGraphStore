---
phase: 02-multi-user-memory
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/config.py
  - backend/app/core/session.py
  - backend/app/core/security.py
  - backend/app/models/schemas.py
autonomous: true

must_haves:
  truths:
    - "Unauthenticated user automatically receives anonymous session ID"
    - "Anonymous session ID stored in HTTP-only cookie (not URL)"
    - "Anonymous user can upload documents and query - same as authenticated"
    - "Anonymous session ID has 'anon_' prefix to distinguish from user UUIDs"
  artifacts:
    - path: "backend/app/core/session.py"
      provides: "Anonymous session generation and cookie management"
      exports: ["generate_anonymous_session_id", "is_anonymous_session", "set_session_cookie", "get_session_from_request"]
    - path: "backend/app/core/security.py"
      provides: "get_current_user_optional that handles both authenticated and anonymous"
      contains: "get_current_user_optional"
  key_links:
    - from: "backend/app/core/security.py"
      to: "backend/app/core/session.py"
      via: "Import session functions for anonymous handling"
      pattern: "from app.core.session import"
---

<objective>
Implement anonymous session management with HTTP-only cookies so unauthenticated users get temporary session IDs that work identically to authenticated users for document operations.

Purpose: Anonymous users can try the system before registering. Their uploads and queries are isolated to their anonymous session. Session stored in HTTP-only cookie for security (prevents XSS token theft).

Output: Session module with anonymous ID generation, get_current_user_optional dependency that handles both auth states seamlessly.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-multi-user-memory/02-RESEARCH.md (Pattern 3: Anonymous Session Management)
@.planning/phases/01-foundation-core-rag/01-02-SUMMARY.md (auth foundation with get_current_user)
@backend/app/core/security.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create anonymous session module with cookie management</name>
  <files>
    backend/app/config.py
    backend/app/core/session.py
  </files>
  <action>
    1. Add to config.py Settings class:
       - ANONYMOUS_SESSION_EXPIRE_DAYS: int = 7
       - ANONYMOUS_PREFIX: str = "anon_"
       - COOKIE_SECURE: bool = True  # Set False for local dev without HTTPS
       - COOKIE_SAMESITE: str = "lax"

    2. Create backend/app/core/session.py:
       ```python
       import secrets
       from datetime import datetime, timezone
       from typing import Optional
       from fastapi import Request, Response
       from app.config import settings

       def generate_anonymous_session_id() -> str:
           """Generate unique anonymous session ID.
           Format: anon_{random_24_chars}
           Prefix distinguishes from authenticated user UUIDs.
           """
           return f"{settings.ANONYMOUS_PREFIX}{secrets.token_urlsafe(24)}"

       def is_anonymous_session(session_id: str) -> bool:
           """Check if session ID is anonymous (starts with prefix)."""
           return session_id.startswith(settings.ANONYMOUS_PREFIX)

       def set_session_cookie(
           response: Response,
           session_id: str,
           max_age_days: int = None
       ) -> None:
           """Set HTTP-only session cookie.

           SECURITY: httponly prevents XSS, secure requires HTTPS, samesite prevents CSRF.
           """
           max_age = (max_age_days or settings.ANONYMOUS_SESSION_EXPIRE_DAYS) * 24 * 3600
           response.set_cookie(
               key="session_id",
               value=session_id,
               max_age=max_age,
               httponly=True,
               secure=settings.COOKIE_SECURE,
               samesite=settings.COOKIE_SAMESITE
           )

       def get_session_from_request(request: Request) -> Optional[str]:
           """Extract session ID from cookie."""
           return request.cookies.get("session_id")

       def clear_session_cookie(response: Response) -> None:
           """Clear session cookie (for logout or session migration)."""
           response.delete_cookie(key="session_id")
       ```

    CRITICAL: Use HTTP-only cookies, never URL parameters (Pitfall #4).
    CRITICAL: Include secure=True for production (HTTPS required).
  </action>
  <verify>
    python -c "
from backend.app.core.session import generate_anonymous_session_id, is_anonymous_session
sid = generate_anonymous_session_id()
print(f'Session ID: {sid}')
assert sid.startswith('anon_'), 'Must have anon_ prefix'
assert is_anonymous_session(sid), 'Must be recognized as anonymous'
assert not is_anonymous_session('user_123'), 'User ID must NOT be anonymous'
print('Session module OK')
"
  </verify>
  <done>
    Session module created with anonymous ID generation and HTTP-only cookie management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create get_current_user_optional dependency for unified auth handling</name>
  <files>
    backend/app/core/security.py
    backend/app/models/schemas.py
  </files>
  <action>
    1. Add to backend/app/models/schemas.py:
       ```python
       class UserContext(BaseModel):
           """User context for request - works for both authenticated and anonymous."""
           id: str  # User UUID or anonymous session ID
           email: Optional[str] = None
           is_anonymous: bool = False
           role: str = "user"  # "user", "admin", or "anonymous"
           session_created: Optional[str] = None  # ISO timestamp for anonymous
       ```

    2. Update backend/app/core/security.py:
       - Add import: `from typing import Optional`
       - Add import: `from fastapi.security import OAuth2PasswordBearer`
       - Create oauth2_scheme_optional = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login", auto_error=False)
       - Add import: `from app.core.session import generate_anonymous_session_id, is_anonymous_session, set_session_cookie, get_session_from_request`
       - Add import: `from datetime import datetime, timezone`

       - Create get_current_user_optional dependency:
         ```python
         async def get_current_user_optional(
             request: Request,
             response: Response,
             token: Optional[str] = Depends(oauth2_scheme_optional)
         ) -> UserContext:
             """Get current user or create/retrieve anonymous session.

             Returns UserContext with 'id' key. For anonymous users:
             - id: anonymous session ID (anon_xxx)
             - is_anonymous: True
             - session_created: timestamp

             CRITICAL: Anonymous and authenticated users use SAME interface.
             All queries filter by user_context.id regardless of auth status.
             """
             if token:
                 # Try to validate JWT
                 try:
                     payload = decode_access_token(token)
                     if payload:
                         user = get_user_by_email(payload.get("sub"))
                         if user:
                             return UserContext(
                                 id=user["id"],
                                 email=user["email"],
                                 is_anonymous=False,
                                 role=user.get("role", "user")
                             )
                 except Exception:
                     pass  # Fall through to anonymous

             # No valid token - use/create anonymous session
             session_id = get_session_from_request(request)

             if not session_id or not is_anonymous_session(session_id):
                 # Create new anonymous session
                 session_id = generate_anonymous_session_id()
                 set_session_cookie(response, session_id)

             return UserContext(
                 id=session_id,
                 is_anonymous=True,
                 role="anonymous",
                 session_created=datetime.now(timezone.utc).isoformat()
             )
         ```

    CRITICAL: Both authenticated and anonymous return same UserContext structure.
    CRITICAL: All database queries use user_context.id for filtering regardless of auth state.
  </action>
  <verify>
    python -c "
from backend.app.core.security import get_current_user_optional, oauth2_scheme_optional
from backend.app.models.schemas import UserContext
print('get_current_user_optional:', get_current_user_optional)
print('oauth2_scheme_optional:', oauth2_scheme_optional)
print('UserContext fields:', UserContext.model_fields.keys())
print('Security module OK')
"
  </verify>
  <done>
    get_current_user_optional dependency created that returns UserContext for both authenticated and anonymous users with unified interface.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update document and query endpoints to support anonymous users</name>
  <files>
    backend/app/api/documents.py
    backend/app/api/queries.py
  </files>
  <action>
    1. Update backend/app/api/documents.py:
       - Change `Depends(get_current_user)` to `Depends(get_current_user_optional)`
       - Update type hint from dict to UserContext
       - Update user_id references from current_user["id"] to current_user.id
       - Import UserContext from models.schemas
       - Import get_current_user_optional from core.security

    2. Update backend/app/api/queries.py:
       - Change `Depends(get_current_user)` to `Depends(get_current_user_optional)`
       - Update type hint from dict to UserContext
       - Update user_id references from current_user["id"] to current_user.id
       - Import UserContext from models.schemas
       - Import get_current_user_optional from core.security

    NOTE: Both endpoints now work for:
    - Authenticated users (with JWT token) -> uses their user UUID
    - Anonymous users (no token) -> gets/creates anonymous session, uses anon_xxx ID

    Data isolation enforced at database level - anonymous users' documents stored with their anon_xxx ID.
  </action>
  <verify>
    # Start server and test:
    # 1. Query without token - should work, get anonymous session cookie
    # curl -c cookies.txt POST http://localhost:8000/api/v1/query -H "Content-Type: application/json" -d '{"query":"test"}'
    # 2. Check cookies.txt has session_id with anon_ prefix
    # 3. Same query with auth token uses authenticated user ID
  </verify>
  <done>
    Document and query endpoints updated to use get_current_user_optional, enabling anonymous access with automatic session creation.
  </done>
</task>

</tasks>

<verification>
Run the following commands to verify Phase 2 Plan 02 completion:

```bash
# 1. Session module works
cd backend && python -c "
from app.core.session import generate_anonymous_session_id, is_anonymous_session
from app.config import settings
sid = generate_anonymous_session_id()
print(f'Generated: {sid}')
print(f'Prefix: {settings.ANONYMOUS_PREFIX}')
assert sid.startswith(settings.ANONYMOUS_PREFIX)
print('Session module OK')
"

# 2. Security module has both dependencies
cd backend && python -c "
from app.core.security import get_current_user, get_current_user_optional
print('get_current_user:', get_current_user)
print('get_current_user_optional:', get_current_user_optional)
print('Security OK')
"

# 3. API test (requires running server)
# Start: uvicorn backend.app.main:app --reload
# Test anonymous query:
# curl -c cookies.txt -b cookies.txt -X POST http://localhost:8000/api/v1/query \
#   -H "Content-Type: application/json" \
#   -d '{"query": "test question"}'
# Check cookies.txt contains session_id starting with anon_
```
</verification>

<success_criteria>
1. Anonymous session IDs generated with configurable prefix (anon_)
2. Session stored in HTTP-only cookie (not URL parameter)
3. get_current_user_optional returns UserContext for both auth states
4. Anonymous users can call /query endpoint without token
5. Anonymous users receive session cookie on first request
6. Subsequent requests use existing session from cookie
7. Document and query endpoints work identically for both user types
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-user-memory/02-02-SUMMARY.md`
</output>
