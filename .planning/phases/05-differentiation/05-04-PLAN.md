---
phase: 05-differentiation
plan: 04
type: execute
wave: 3
depends_on: ["05-03"]
files_modified:
  - backend/app/services/memory_service.py
  - backend/app/api/memory.py
  - backend/app/models/schemas.py
  - backend/app/config.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "User can add arbitrary facts to their private memory"
    - "User facts influence future query responses"
    - "Admin can add facts to shared memory"
    - "All authenticated users can query against shared knowledge"
    - "Memory endpoints require authentication"
    - "Anonymous users cannot use memory endpoints"
  artifacts:
    - path: "backend/app/services/memory_service.py"
      provides: "Memory management with shared memory support"
      exports: ["add_user_memory", "search_user_memories", "add_shared_memory", "get_user_memories"]
    - path: "backend/app/api/memory.py"
      provides: "Memory API endpoints"
      contains: "@router.post"
    - path: "backend/app/config.py"
      provides: "SHARED_MEMORY_USER_ID constant"
      contains: "SHARED_MEMORY_USER_ID"
    - path: "backend/app/main.py"
      provides: "Memory router registered"
      contains: "memory.router"
  key_links:
    - from: "backend/app/api/memory.py"
      to: "backend/app/services/memory_service.py"
      via: "import memory functions"
      pattern: "from app.services.memory_service import"
    - from: "backend/app/main.py"
      to: "backend/app/api/memory.py"
      via: "router registration"
      pattern: "from app.api import memory"
---

<objective>
Implement memory API endpoints for private and shared knowledge management.

Purpose: Enable users to add facts to their private memory (Success Criteria #3) and admins to manage shared company knowledge (Success Criteria #5). User memories influence query responses, providing personalization.

Output: Memory service with private/shared support, API endpoints, and integration with query context.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-differentiation/05-RESEARCH.md

# Existing files to extend
@backend/app/config.py
@backend/app/main.py
@backend/app/models/schemas.py
@backend/app/db/mem0_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Shared Memory Config and Memory Service</name>
  <files>backend/app/config.py, backend/app/services/memory_service.py</files>
  <action>
1. In config.py, add shared memory configuration:
```python
# Shared Memory
SHARED_MEMORY_USER_ID: str = "__shared__"  # Sentinel user_id for company-wide knowledge
```

2. Create memory_service.py with functions for memory management:

```python
async def add_user_memory(user_id: str, content: str, metadata: Optional[dict] = None) -> dict:
```
- Use Mem0 client to add memory for user
- Include metadata with type="fact" marker
- Return dict with memory_id

```python
async def search_user_memories(user_id: str, query: str, limit: int = 5, include_shared: bool = True) -> List[dict]:
```
- Search user's private memories using Mem0
- If include_shared=True, also search shared memories (SHARED_MEMORY_USER_ID)
- Combine and sort by relevance score
- Return list of memory dicts with: id, memory, score, metadata, is_shared

```python
async def get_user_memories(user_id: str, limit: int = 50) -> List[dict]:
```
- List all memories for user (no search, just list)
- Return list of memory dicts

```python
async def add_shared_memory(content: str, admin_id: str, metadata: Optional[dict] = None) -> dict:
```
- Add memory with user_id=SHARED_MEMORY_USER_ID
- Include admin_id in metadata for audit trail
- Return dict with memory_id

Import from app.db.mem0_client: get_mem0_client
Import from app.config: settings
  </action>
  <verify>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend
python -c "from app.services.memory_service import add_user_memory, search_user_memories, add_shared_memory, get_user_memories; print('Imports OK')"
python -c "from app.config import settings; print('SHARED_MEMORY_USER_ID:', settings.SHARED_MEMORY_USER_ID)"
```
  </verify>
  <done>SHARED_MEMORY_USER_ID added to config. Memory service created with add_user_memory, search_user_memories, add_shared_memory, get_user_memories.</done>
</task>

<task type="auto">
  <name>Task 2: Add Memory Schemas and API Endpoints</name>
  <files>backend/app/models/schemas.py, backend/app/api/memory.py</files>
  <action>
1. In schemas.py, add memory-related schemas:

```python
class MemoryAddRequest(BaseModel):
    """Schema for adding a memory/fact."""
    content: str
    metadata: Optional[dict] = None

class MemoryItem(BaseModel):
    """Schema for a single memory item."""
    id: str
    memory: str
    metadata: Optional[dict] = None
    is_shared: bool = False

class MemoryListResponse(BaseModel):
    """Schema for memory list response."""
    memories: List[MemoryItem]
    count: int

class MemoryAddResponse(BaseModel):
    """Schema for memory add response."""
    status: str
    memory_id: str
    scope: str  # "private" or "shared"
```

2. Create memory.py API router with endpoints:

```python
router = APIRouter(prefix="/memory", tags=["memory"])

@router.post("/", response_model=MemoryAddResponse)
async def add_memory(request: MemoryAddRequest, current_user: dict = Depends(get_current_user)):
```
- Reject anonymous users with 401
- Call add_user_memory with current_user["id"]
- Return MemoryAddResponse with scope="private"

```python
@router.post("/shared", response_model=MemoryAddResponse)
async def add_shared_memory_endpoint(request: MemoryAddRequest, current_user: dict = Depends(get_current_user)):
```
- Check if user is admin (current_user.get("role") == "admin")
- If not admin, return 403 Forbidden
- Call add_shared_memory with admin_id=current_user["id"]
- Return MemoryAddResponse with scope="shared"

Note: Full RBAC with require_admin dependency planned for Phase 2. For now, simple role check.

```python
@router.get("/", response_model=MemoryListResponse)
async def list_memories(include_shared: bool = True, limit: int = 50, current_user: dict = Depends(get_current_user)):
```
- Reject anonymous users with 401
- Get private memories via get_user_memories
- If include_shared, also get shared memories with settings.SHARED_MEMORY_USER_ID
- Mark shared memories with is_shared=True
- Return combined list

Import from fastapi: APIRouter, Depends, HTTPException, status
Import from app.core.security: get_current_user
Import from app.services.memory_service: add_user_memory, add_shared_memory, get_user_memories
Import from app.models.schemas: MemoryAddRequest, MemoryAddResponse, MemoryListResponse, MemoryItem
  </action>
  <verify>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend
python -c "from app.api.memory import router; print('Memory router created')"
python -c "from app.models.schemas import MemoryAddRequest, MemoryAddResponse, MemoryListResponse, MemoryItem; print('Memory schemas OK')"
```
  </verify>
  <done>Memory schemas added to schemas.py. Memory API router created with POST /, POST /shared, GET / endpoints.</done>
</task>

<task type="auto">
  <name>Task 3: Register Memory Router and Update Enhanced Query</name>
  <files>backend/app/main.py, backend/app/api/queries.py</files>
  <action>
1. In main.py, register the memory router:
```python
from app.api import auth, documents, queries, memory

# Add memory router registration
app.include_router(
    memory.router,
    prefix=settings.API_V1_PREFIX + "/memory",
    tags=["memory"]
)
```

Note: Remove the prefix from include_router if router already has prefix="/memory".

2. In queries.py, update the enhanced query endpoint to include memory context:

In the query_documents_enhanced function, after retrieving document context:
```python
# Step 2: Retrieve user memories (if authenticated and not anonymous)
memory_context = []
if not current_user.get("is_anonymous", False):
    from app.services.memory_service import search_user_memories
    memories = await search_user_memories(
        user_id=current_user["id"],
        query=request.query,
        limit=3,
        include_shared=True
    )
    memory_context = [
        {"text": m.get("memory", ""), "filename": "User Memory", "score": m.get("score", 0.5)}
        for m in memories
    ]

# Step 3: Combine document + memory context
all_context = context["chunks"] + memory_context
```

Pass all_context to generate_answer_with_confidence instead of just context["chunks"].
Only extract highlighted citations from document chunks (not memory context).
  </action>
  <verify>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend
python -c "from app.main import app; print('App loads OK')"
python -c "from app.api.queries import query_documents_enhanced; print('Enhanced query function exists')"
```
  </verify>
  <done>Memory router registered in main.py. Enhanced query endpoint updated to include user memory context in responses.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend

# Verify all imports work
python -c "
from app.services.memory_service import add_user_memory, search_user_memories, add_shared_memory, get_user_memories
from app.api.memory import router as memory_router
from app.models.schemas import MemoryAddRequest, MemoryAddResponse, MemoryListResponse, MemoryItem
from app.config import settings
print('All imports successful')
print('SHARED_MEMORY_USER_ID:', settings.SHARED_MEMORY_USER_ID)
"

# Verify main.py loads with memory router
python -c "
from app.main import app
routes = [r.path for r in app.routes]
memory_routes = [r for r in routes if 'memory' in r]
print('Memory routes:', memory_routes)
"

# Verify no syntax errors
python -m py_compile app/services/memory_service.py
python -m py_compile app/api/memory.py
python -m py_compile app/main.py
python -m py_compile app/api/queries.py
echo "Syntax validation passed"
```
</verification>

<success_criteria>
1. SHARED_MEMORY_USER_ID="__shared__" added to settings
2. memory_service.py has add_user_memory, search_user_memories, add_shared_memory, get_user_memories
3. Memory schemas (MemoryAddRequest, MemoryAddResponse, MemoryListResponse, MemoryItem) added
4. POST /memory endpoint for private memories
5. POST /memory/shared endpoint for admin-only shared memories
6. GET /memory endpoint lists private + optional shared memories
7. Memory router registered in main.py
8. Enhanced query includes user/shared memory in context
9. Anonymous users rejected from memory endpoints with 401
10. Non-admin users rejected from /memory/shared with 403
</success_criteria>

<output>
After completion, create `.planning/phases/05-differentiation/05-04-SUMMARY.md`
</output>
