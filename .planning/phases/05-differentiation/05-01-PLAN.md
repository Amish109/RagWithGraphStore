---
phase: 05-differentiation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/summarization_service.py
  - backend/app/api/queries.py
  - backend/app/models/schemas.py
autonomous: true

must_haves:
  truths:
    - "User can request a summary of any uploaded document without re-uploading"
    - "Summary is generated from stored chunks, not requiring original file"
    - "Multiple summary types available (brief, detailed, executive, bullet)"
    - "Summaries are cached to avoid regeneration on repeated requests"
  artifacts:
    - path: "backend/app/services/summarization_service.py"
      provides: "Document summarization with map-reduce for long docs"
      exports: ["summarize_document", "get_document_text", "SUMMARY_PROMPTS"]
    - path: "backend/app/api/queries.py"
      provides: "GET /documents/{document_id}/summary endpoint"
      contains: "@router.get"
    - path: "backend/app/models/schemas.py"
      provides: "SummaryResponse schema"
      contains: "class SummaryResponse"
  key_links:
    - from: "backend/app/api/queries.py"
      to: "backend/app/services/summarization_service.py"
      via: "import summarize_document"
      pattern: "from app.services.summarization_service import"
    - from: "backend/app/services/summarization_service.py"
      to: "backend/app/db/neo4j_client.py"
      via: "chunk retrieval for document text"
      pattern: "neo4j_driver.session"
---

<objective>
Implement on-demand document summarization service that generates summaries from stored chunks.

Purpose: Enable users to get document summaries at any time without re-uploading files (QRY-06). This provides value by allowing quick document overview without reading the entire content.

Output: Summarization service with caching, API endpoint for summary requests, and response schemas.
</objective>

<execution_context>
@/Users/apple/.claude/get-shit-done/workflows/execute-plan.md
@/Users/apple/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-differentiation/05-RESEARCH.md

# Existing files to extend
@backend/app/services/retrieval_service.py
@backend/app/api/queries.py
@backend/app/models/schemas.py
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Summarization Service</name>
  <files>backend/app/services/summarization_service.py</files>
  <action>
Create new summarization service implementing on-demand document summaries:

1. Define SUMMARY_PROMPTS dictionary with prompt templates for:
   - "brief": 2-3 sentence overview
   - "detailed": Comprehensive coverage
   - "executive": Business-focused with recommendations
   - "bullet": Key points as bulleted list

2. Implement `get_document_text(document_id: str, user_id: str) -> Optional[str]`:
   - Query Neo4j to retrieve all chunks for document
   - CRITICAL: Filter by user_id for multi-tenant isolation
   - Order chunks by position
   - Join chunk texts with double newlines
   - Return None if document not found or user doesn't have access

3. Implement `_cache_key(document_id: str, summary_type: str) -> str`:
   - Use hashlib.sha256 to generate cache key
   - Format: hash of "{document_id}:{summary_type}"

4. Implement `summarize_document(document_id, user_id, summary_type, max_chunks, use_cache, cache_dict) -> Optional[dict]`:
   - Check in-memory cache first (simple dict, Redis deferred to Phase 2)
   - Get document text via get_document_text()
   - For short documents (<10000 chars): use "stuff" method (single prompt)
   - For long documents: use map-reduce pattern
     - Split into 4000-char chunks
     - Summarize each chunk individually (map phase)
     - Combine chunk summaries into final summary (reduce phase)
   - Cache result in cache_dict
   - Return dict with: document_id, summary_type, summary, method, (chunks_processed if map-reduce)

Use ChatOpenAI with temperature=0.3 for slight creativity in summaries.
Use langchain_core.prompts.ChatPromptTemplate (not deprecated langchain.prompts).
Follow existing patterns from generation_service.py.
  </action>
  <verify>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend
python -c "from app.services.summarization_service import summarize_document, get_document_text, SUMMARY_PROMPTS; print('Imports OK')"
```
  </verify>
  <done>Summarization service exists with get_document_text, summarize_document, and SUMMARY_PROMPTS exported. Both stuff and map-reduce methods implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Add Summary Schema and API Endpoint</name>
  <files>backend/app/models/schemas.py, backend/app/api/queries.py</files>
  <action>
1. In schemas.py, add SummaryResponse model:
```python
class SummaryResponse(BaseModel):
    """Schema for document summary response."""
    document_id: str
    summary_type: str
    summary: str
    method: str  # "stuff" or "map_reduce"
    chunks_processed: Optional[int] = None
```

2. In queries.py, add GET endpoint for document summary:
```python
@router.get("/documents/{document_id}/summary", response_model=SummaryResponse)
async def get_document_summary(
    document_id: str,
    summary_type: str = Query(default="brief", enum=["brief", "detailed", "executive", "bullet"]),
    current_user: dict = Depends(get_current_user),
):
```

Endpoint implementation:
- Import summarize_document from summarization_service
- Create module-level cache dict (simple in-memory cache for now)
- Call summarize_document with user_id from current_user["id"]
- Return 404 HTTPException if document not found or no access
- Return SummaryResponse on success

Import Query from fastapi for enum validation.
Import HTTPException for error handling.
  </action>
  <verify>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend
python -c "from app.api.queries import router; from app.models.schemas import SummaryResponse; print('Imports OK')"
```
  </verify>
  <done>SummaryResponse schema added to schemas.py. GET /documents/{document_id}/summary endpoint added to queries.py with summary_type query parameter.</done>
</task>

<task type="auto">
  <name>Task 3: Integration Test with Manual Verification</name>
  <files>None (verification only)</files>
  <action>
Verify the complete summarization flow works:

1. Start the FastAPI server (if not running):
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend
uvicorn app.main:app --reload --port 8000
```

2. Test the endpoint exists (should return 401 without auth):
```bash
curl -s http://localhost:8000/api/v1/queries/documents/test-doc-id/summary | head -20
```

3. Verify the summarization service can be imported and has correct exports:
```bash
python -c "
from app.services.summarization_service import summarize_document, get_document_text, SUMMARY_PROMPTS
print('Summary types:', list(SUMMARY_PROMPTS.keys()))
print('Functions available: get_document_text, summarize_document')
"
```

4. Verify schema has all required fields:
```bash
python -c "
from app.models.schemas import SummaryResponse
print('SummaryResponse fields:', SummaryResponse.model_fields.keys())
"
```

Note: Full end-to-end testing requires uploaded documents which depends on Phase 1 being complete and Neo4j/Qdrant running. The structural verification ensures the code is correct.
  </action>
  <verify>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend
python -c "from app.services.summarization_service import SUMMARY_PROMPTS; assert len(SUMMARY_PROMPTS) == 4, 'Expected 4 summary types'; print('OK: 4 summary types defined')"
```
  </verify>
  <done>Summarization service imports correctly, has 4 summary types (brief, detailed, executive, bullet), SummaryResponse schema has required fields.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/apple/Desktop/RAGWithGraphStore/backend

# Verify all imports work
python -c "
from app.services.summarization_service import summarize_document, get_document_text, SUMMARY_PROMPTS
from app.api.queries import router
from app.models.schemas import SummaryResponse
print('All imports successful')
print('Summary types:', list(SUMMARY_PROMPTS.keys()))
"

# Verify no syntax errors in modified files
python -m py_compile app/services/summarization_service.py
python -m py_compile app/api/queries.py
python -m py_compile app/models/schemas.py
echo "Syntax validation passed"
```
</verification>

<success_criteria>
1. summarization_service.py exists with get_document_text, summarize_document, SUMMARY_PROMPTS
2. SUMMARY_PROMPTS contains 4 types: brief, detailed, executive, bullet
3. SummaryResponse schema added to schemas.py
4. GET /documents/{document_id}/summary endpoint added to queries.py
5. All files pass syntax validation
6. Summarization uses map-reduce for long documents (>10000 chars)
7. User isolation enforced via user_id filtering in Neo4j queries
</success_criteria>

<output>
After completion, create `.planning/phases/05-differentiation/05-01-SUMMARY.md`
</output>
